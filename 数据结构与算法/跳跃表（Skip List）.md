# 跳跃表（Skip List）

跳跃表是一种比较神秘的数据结构，它在学校教材或者很多数据结构的书籍中都没有被提及。很多人都是学习Redis才了解到跳跃表这个数据结构的。这里就来介绍一下跳跃表的结构。

## 链表

在讲跳跃表之前，我们先来回忆一下单链表。

大家都知道，单链表的结构就是有很多个节点，通过指针跟后面的节点连接在一起（除了最末尾的节点），最终形成了链表。

![](http://img.fosuchao.com/20200522111354.png)

### 查询 修改

根据单链表的结构，我们可以很容易的发现，链表的查询操作是需要从第一次节点开始往后面遍历，直到找到目标节点为止。添加和删除操作则同理。这样的话时间复杂度为log(n)，可以说是比较慢的。

那么怎么才能提升链表结构的查询效率呢？答案是有的。

## 跳表

### 介绍

跳表中的节点是有序的。一般是按照从小到大的顺序来排序。redis中的zset就是根据score的值来排序。

### 链表的演变

我们可以从链表中抽出几个节点元素，构成一个索引，如下图。

![](http://img.fosuchao.com/20200522112045.png)

比如我们要查找值为4的节点。在添加了索引后，遍历的过程变成了**1 -> 3 -> 4**，如果没有添加索引的话，按照原始链表的遍历顺序应该是**1 -> 2 -> 3 -> 4**，遍历的节点数减少了1个。

可能很多人会有疑问，好像这个遍历也每快多少啊？感觉差不多嘛。其实不然。

因为这里举例子，节点数量很少，并且这里是一级索引，在真实的跳表结构中。是由海量的数据组成的。并且有多级索引。这样效率的提升就非常明显了。

![](http://img.fosuchao.com/20200522112808.png)

通过最高级索引直接跳过了4个元素，次高层索引直接跳过了2个元素，**从而使得链表能够实现二分查找**。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。

这时，我们大概就可以给跳表一个定义了。跳表就是一个**实现二分查找的排序链表**。

## 跳表与红黑树

红黑树是一种平衡二叉树，是在很多场景下都经常会使用到的底层数据结构。红黑树的结构复杂，但它的操作有着良好的最坏情况[运行时间](https://zh.wikipedia.org/wiki/算法分析)，并且在实践中高效：它可以在`log(N)`的时间内完成查找、插入和删除，这里的N是树中元素的数目。

红黑树的结构如下，其它红黑树的概念这里不再赘述。

![](http://img.fosuchao.com/20200522113515.png)

### 为什么是跳表

1 skiplist的复杂度和红黑树一样，而且实现起来更简单。

2 在并发环境下skiplist有另外一个优势，**红黑树在插入和删除的时候可能需要做一些rebalance**的操作，这样的操作可能会涉及到整个树的其他部分，而skiplist的操作显然更加局部性一些，锁需要盯住的节点更少，因此在这样的情况下性能好一些。

## 复杂度

### 空间复杂度

跳表通过建立索引，来提高查找元素的效率，就是典型的“**空间换时间**”的思想，所以在空间上做了一些牺牲，那空间复杂度到底是多少呢？

假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，**空间复杂度是 O(n)**。

### 查找的时间复杂度

既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以**时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。**

跳表的索引高度 h = log2n，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 O(3*logn)，省略常数即：**O(logn)**。

## 跳表的修改操作

### 插入数据

![](http://img.fosuchao.com/20200522114859.png)

根据跳表查找的机制，很容易就将6插入到5和9之间。然而插入真的就那么简单吗？显然是不能那么简单的。

比如举个例子，如果我们插入数据都集中在同一个范围下，比如2500到5000之间。而一级索引的跨度就是2500。那么就导致当后续的查找目标在2500-5000范围的时候，时间复杂度会变成log(N)。那又变回糟糕的效率了。

#### 重建索引

这种情况是发生在我们不重新重建更新索引的条件下。那么我们插入了数据后就重建索引，那是不是就能解决这个问题了呢？

![](http://img.fosuchao.com/20200522120518.png)

**重建过后**

![](http://img.fosuchao.com/20200522120643.png)

我们每次插入数据后，都把这**个跳表的索引删掉全部重建**，重建索引的时间复杂度是多少呢？因为索引的空间复杂度是 O(n)，即：索引节点的个数是 O(n) 级别，每次完全重新建一个 O(n) 级别的索引，时间复杂度也是 O(n) 。造成的后果是：**为了维护索引，导致每次插入数据的时间复杂度变成了 O(n)。**

#### 重建优化

比起重建索引，我们根据每一层的索引层来添加相应的索引会使效率高很多

![](http://img.fosuchao.com/20200522125330.png)

index-2中遍历，发现6在1-9之间，那么就在1-9之间添加一个节点值为6.

index-1中遍历，发现6在5-9之间，那么就在5-9之间添加一个节点值为6.

这样按需添加的事件复杂度是O(1)，最终插入的时间复杂度仍然为log(N)，使效率几乎没有发生变化，并且查询的效率也维持了。

### 删除数据

删除数据跟插入的原理相同，由上至下将删除的节点删除即可。同样是O(1)的时间复杂度。

![](http://img.fosuchao.com/20200522125907.png)

### 总结

1. 跳表是可以实现二分查找的有序链表；
2. 每个元素插入时随机生成它的level；
3. 最底层包含所有的元素；
4. 如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；
5. 每个索引节点包含两个指针，一个向下，一个向右；（笔记目前看过的各种跳表源码实现包括Redis 的zset 都没有向下的指针，那怎么从二级索引跳到一级索引呢？留个悬念，看源码吧，文末有跳表实现源码）
6. 跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；

