# Docker和虚拟机的隔离机制

# Docker容器实现原理及容器隔离性踩坑介绍

> 正如Docker官方的口号：“Build once,Run anywhere,Configure once,Run anything”，Docker被贴上了如下标签：轻巧、秒级启动、版本管理、可移植性等等，这些优点让它出现之初就收到极大的关注。现在，Docker已经不仅仅是开发测试阶段使用的工具，大家已经在生产环境中大量使用。今天我们给大家介绍关于容器隔离性的一个“坑”。在此之前，我们先来回顾一下Docker容器的底层实现原理。

### 容器底层实现

我们都知道，虚拟机与容器的底层实现原理是不同的，正如下图对比：


关于Docker实现原理，简单总结如下：

- 使用**Namespaces**实现了系统环境的隔离，Namespaces允许一个进程以及它的子进程从共享的宿主机内核资源（网络栈、进程列表、挂载点等）里获得一个仅自己可见的隔离区域，让同一个Namespace下的所有进程感知彼此变化，对外界进程一无所知，仿佛运行在一个独占的操作系统中；
- 使用CGroups限制这个环境的资源使用情况，比如一台16核32GB的机器上只让容器使用2核4GB。使用CGroups还可以为资源设置权重，计算使用量，操控任务（进程或线程）启停等；
- 使用镜像管理功能，利用Docker的镜像分层、写时复制、内容寻址、联合挂载技术实现了一套完整的容器文件系统及运行环境，再结合镜像仓库，镜像可以快速下载和共享，方便在多环境部署。


正因为Docker不像虚机虚拟化一个Guest OS，而是利用宿主机的资源，和宿主机共用一个内核，所以会存在下面问题：
1、Docker是利用CGroups实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源;