# JVM字节码执行引擎

## 介绍

执行引擎是Java虚拟机核心的组成部分之一。“虚拟机''是一个相对于“物理机''的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有**解释执行**（通过解释器执行）和**编译执行**（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。

但从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：**输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果**。

本文将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。

## 栈帧

栈帧就是方法调用和方法执行背后的数据结构，也属于虚拟栈的一部分。

一个方法的执行开始和执行结束就对应着一个栈帧在虚拟机栈中的入栈和出栈过程。

一个栈桢包括了局部变量表，操作数栈，动态链接，方法出口等一些额外的信息。只有位于虚拟机栈顶的栈帧是有效的，即是当前方法，正在执行中的方法。也叫当前栈帧。**执行引擎所执行的所有字节码指令都只针对当前栈帧进行操作。**

### 局部变量表

局部变量表是一组变量的存储空间，用于存放方法内部定义的局部变量和方法参数。

局部变量表的容量以变量槽（Variable Slot）为最小单位。每个变量槽都应该能存放**boolean、byte、short、int、float、reference或returnAddress**类型的数据，这些数据类型都能用4个字节或者更小的物理内存来存储。

![image-20200724174644808](http://img.fosuchao.com/image-20200724174644808.png)

### 操作数栈

操作数栈是一个后入先出（LIFO) 的栈。操作数栈的每一个元素都可以是包括**long和double在内的任意Java数据类型**。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。![image-20200724175154973](http://img.fosuchao.com/image-20200724175154973.png)

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(DynmncLmkmg)。

我们知道CIass文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

### 方法返回地址（方法出口）

当一个方法开始执行后，只有两种方式退出这个方法。

第一种方式是执行引擎遇到任意一个方法返回的字节码指令，将方法返回值返回给上层调用者，这种退出方法的方式称为**正常调用完成**。

另外一种退出方式是在方法执行的过程中遇到了异常，遇到异常的时候是不会给它的上层调用者提供任何返回值的。

无论采用何种退出方式，**在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态**。一般来说，方法正常退出时，主调方法的pc计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整pc计数器的值以指向方法调用指令后面的一条指令等。笔者这里写的“可能。'是由于这是基于概念模型的讨论，只有具体到某一款Java虚拟机实现，会执行哪些操作才能确定下来。

## 基于栈的字节码解释执行引擎

JVM的执行引擎在执行Java代码的时候都有解释执行和编译执行。

解释执行：解释器执行

编译执行：通过即时编译器产生本地代码执行

### 解释执行

![image-20200724184911150](http://img.fosuchao.com/image-20200724184911150.png)

