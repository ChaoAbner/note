# JVM类加载

JVM由三个主要的子系统构成

- 类加载器系统

- 运行时数据区（内存结构）

- 执行引擎

## JVM的整体结构

​		我们写好的.java文件通过java编译器编译后，生成.class字节码文件，类加载器将.class文件加载到运行时数据区，执行引擎执行.class文件。

![](http://img.fosuchao.com/20200304093020.png)

## 类加载过程

​		类加载过程分成多个部分。

![](http://img.fosuchao.com/20200304093326.png)

类加载：类加载器将class文件加载到虚拟机的内存

- 加载：在硬盘上查找并通过IO读入字节码文件
- 连接：执行校验、准备、解析（可选）步骤
  - 校验：校验字节码文件的正确性
  - 准备：给类的静态变量分配内存，并赋予默认值
  - 解析：类装载器装入类所引用的其他所有类
- 初始化：对类的静态变量初始化为指定的值，执行静态代码块



VM加载jar包是否会将包里的所有类全部加载进内存？

答：JVM对class文件是**按需加载**(**运行期间动态加载**)，非一次性加载，见示例(启动需要加上参数：`-verbose:class`，可查看启动时类加载过程。)

## 类加载器种类

- 启动类加载器（Bootstrap ClassLoader）：

  负责加载JRE的核心类库，如`jre`目标下的`rt.jar, charsets.jar`等

- 扩展类加载器（Extension ClassLoader）：

  负责加载JRE扩展目录`ext`中JAR类包

- 系统类加载器（Application ClassLoader）

  负责加载`ClassPath`路径下的类包，就是我们写的代码

- 自定义类加载器（Custom ClassLoader）：

  负责加载用户自定义路径下的类包

## 类加载机制

![](http://img.fosuchao.com/20200304093800.png)

- 全盘负责委托机制：

  当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入

- 双亲委派机制：

  先委托上级加载器寻找目标类，直到启动类加载器，如果还找不到，则在交给子加载器处理。如果找到了，则结束。

### 双亲委派模式优势

- 沙箱安全机制：防止JDK的核心类被恶意篡改
- 避免类的重复加载：当上级类加载器加载成功，就没有必要由子加载器再次加载。