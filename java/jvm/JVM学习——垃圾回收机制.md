# JVM学习——垃圾回收机制

垃圾回收——garbage collection,简称GC。垃圾回收主要发生在堆内存，

## **JVM内存分配与回收**

​		大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

 **新生代GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。

 **老年代GC（Major GC/Full GC）**:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

​		通常一个Minor GC的时间是几毫秒。而Full GC的时间可能达到了几十或者几百毫秒，所以我们垃圾回收和JVM调优的目的即就是为了**减少Full GC的次数和GC的时间**。

### 分配的情况

​		当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。

### 大对象直接进入老年代

大对象就是需要**大量连续内存空间**的对象（比如：字符串、数组）。

**为什么要这样呢？**

为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

### 长期存活的对象将进入老年代

​		如果不算是大对象，在发生一次Minor GC后，对象可以被Survior空间存入，那么会被放到Survior中，对象年龄变成1，Survivor 中每熬过一次 MinorGC，这个对象会在Survior0、1之间来回复制，每次复制这个对象的年龄就会增长，当**年龄到达15**（默认）的时候，这个对象还没有被清除，那么就会被移动到老年代。这个年龄是可以通过JVM参数设置的。

## 如何判断对象可以被回收

​		只有达到回收的条件的对象，才会被回收。所以垃圾回收前的第一布就是判断这些对象是否死亡。（没有任何引用的对象）

### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 

循环引用例子：

​		所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。

![](http://img.fosuchao.com/20200304135710.png)

导致堆中对象的这种循环引用

![1583301510829](F:\typoraImg\1583301510829.png)

### 可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

**GC Roots**根节点：**类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等等**

![](http://img.fosuchao.com/20200304135929.png)

### finalize()方法判定对象是否存活

可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。

**标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。**

**1、第一次标记并进行一次筛选**

筛选的条件是此对象是否有必要执行finalize()方法。

如果对象判断为没有必要执行finalize方法：

当对象**没有覆盖finalize方法**，或者**finzlize方法已经被虚拟机调用**过，虚拟机将这两种情况都视为“没有必要执行”，对象**被回收**。

**2. 第二次标记**

如果这个对象被判定为**有必要执行**finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。

finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，**那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了**。

### 判断一个常量是废弃常量

运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？

假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

### 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 **“无用的类”** ：

-  该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。

-  加载该类的 ClassLoader 已经被回收。

-  该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

 

## 垃圾收集算法

垃圾收集算法主要由三种：**标记-清除算法、复制算法、标记-整理算法**。

分代收集算法实则是对新生代和老年代采用不同的收集算法，实际采用的算法还是以上三种。

![](http://img.fosuchao.com/20200304140925.png)

### 标记-清除算法

​		算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：

1、标记阶段：标记的过程就是前面的**可达性分析法**执行的过程。首先**遍历所有 GC Roots 对象**，对从 GC Roots 对象可达的对象都打上一个可达标识。这个可达标识一般记录在对象 header 中（一个对象一般包括对象头、实例数据、对齐填充三个部分），表示该对象可以被 GC Roots 访问。参考下图（图来自网上）



![img](https:////upload-images.jianshu.io/upload_images/6762021-18c73d39d1889f60.png?imageMogr2/auto-orient/strip|imageView2/2/w/660/format/webp)

可以看到，上图 B、E、F、G、J、K 对象是可达对象，所以这些对象的对象头中就会记录可达信息。

​	2、清除阶段：清除阶段是对堆内存进行遍历，通过读取这些对象的 header 信息来获取对象是否标记可达。如果**未标记则表示这些对象没有引用，就可以进行回收**。



![img](https:////upload-images.jianshu.io/upload_images/6762021-d25f19b967f2cb94.png?imageMogr2/auto-orient/strip|imageView2/2/w/643/format/webp)

标记 - 清除算法主要不足有两个：

- 效率问题：标记和清除都需要遍历，**效率不高**；
- 空间问题：标记清除后会产生大量不连续的内存水平**，空间碎片太多**会导致大内存对象无法生成而频繁进行 GC。

### 复制算法

为了解决效率问题，“复制”收集算法出现了。它可以将**内存分为大小相同的两块**，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是**对内存区间的一半进行回收**。

![](http://img.fosuchao.com/20200304141512.png)

缺点：

- 需要两倍的内存空间

- 如果对象存活率高，需要复制的对象比较多，产生效率问题。

通常复制算法使用在年轻代，特别是在survior0、1两个内存区域之间相互复制的时候特别适合使用复制算法。

### 标记-整理算法

根据**老年代**的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。

![](http://img.fosuchao.com/20200304141750.png)

回收后

- 优点：无需复制，保证效率。内存规整。
- 缺点：效率不如复制算法。

##### 三种算法排行

在了解了以上三种 GC 算法以后，作一个简单的排行：

**效率：**复制算法 > 标记-整理算法 > 标记-清除 算法（标记 - 清除会产生内存碎片，需要大内存时会出发新一轮 GC）。

**内存规整率：**复制算法 = 标记-整理 > 标记-清除。

**内存利用率：**标记-整理算法 = 标记-清除算法 > 复制算法。

### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

## 垃圾收集器

![](http://img.fosuchao.com/20200304141929.png)

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**。

### CMS（Concurrent Mark Sweep）收集器：

[参考文章](https://blog.nowcoder.net/n/4ccac0f84928482eaa7e9a65f39a277f)

CMS收集器是**一种以获取最短回收停顿时间为目标**的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种**老年代收集器**，通常与**ParNew**一起使用。

**CMS的垃圾收集过程分为4步：**

- **初始标记**：需要“Stop the World”，初始标记仅仅只是**标记一下GC Root能直接关联到的对象**，速度很快。
- **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。
- **重新标记**：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。
- **并发清除**：和用户线程并发执行的，**基于标记结果来清理对象**。

![](http://img.fosuchao.com/20200304142440.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- 对CPU资源敏感（会和服务抢资源）

-  无法处理浮动垃圾(在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)

-  它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

### G1（Garbage-First）收集器

![](http://img.fosuchao.com/20200304142844.png)

![](http://img.fosuchao.com/20200304142902.png)

G1收集器**将新生代和老年代取消了**，取而代之的是**将堆划分为若干的区域**，仍然属于分代收集器，区域的一部分包含新生代，**新生代采用复制算法，老年代采用标记-整理算法**。分配大对象（直接进**Humongous区，专门存放短期巨型对象**，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。

通过**将JVM堆分为一个个的区域（region）**,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的region。**

**G1收集器的特点：**

- **并行与并发**：G1能充分利用多CPU，多核环境下的硬件优势，来**缩短Stop the World**，是**并发的收集器**。
- **分代收集**：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。
- **空间整合**：G1从整体来看是基于**标记-整理算法**，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。
- **可预测的停顿**： 这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能**建立可预测的停顿时间模型**，能让使用者明确指定在一个长度为M毫秒的时间片段内完成垃圾收集。

G1收集器的运作大致分为以下几个步骤：

- **初始标记**（initial mark，STW）：在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。
-  **并发标记**（Concurrent Marking）：G1 GC 在整个堆中查找可访问的（存活的）对象。
-  **最终标记**（Remark，STW）：该阶段是 STW 回收，帮助完成标记周期。
-  **筛选回收**（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，**根据用户所期望的GC停顿时间来制定回收计划**，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

![](http://img.fosuchao.com/20200304143302.png)

**G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率。

### 如何选择垃圾收集器

 优先调整堆的大小让服务器自己来选择

 如果内存小于100M，使用串行收集器

 如果是单核，并且没有停顿时间的要求，串行或JVM自己选择

 如果允许停顿时间超过1秒，选择并行或者JVM自己选

 如果响应时间最重要，并且不能超过1秒，使用并发收集器

下图有连线的可以搭配使用，官方推荐使用G1，因为性能高

![](http://img.fosuchao.com/20200304143422.png)