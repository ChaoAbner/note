HashMap是实现了Map接口一种哈希表，提供key-value的映射操作

允许null值和null键，除了**非同步和允许null**之外，其他基本和HashTable相同

HashMap是**非有序的哈希表，并不保证映射的顺序**，即先put进行的元素，不一定就会先取出来

因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。

## 类图

![image-20201203102828872](http://img.fosuchao.com/image-20201203102828872.png)

## 成员变量

![image-20201203092717375](http://img.fosuchao.com/image-20201203092717375.png)

解释下一些比较重要的成员变量的意义

### **DEFAULT_INITIAL_CAPACITY**

默认初始容量必须是2的幂，因为要

元素放置的位置是由`(n - 1) & hash`这种方式计算的（n是hashmap的容量），而不是直接采用取模的方式（hash % n）

正是因为这种计算方式，如果n为2的幂，那么n-1后便使后面的位都是1，这样进行与运算的时候便可以保留hash中后 x 位的 1，如果n不是2的幂，有些桶总是无法通过计算得到，就导致了计算出桶的位置不均匀，

> 例如 00001111 & 10000011 = 00000011

这样的好处

- &运算速度快，至少比%取模运算块
- 能保证 索引值 肯定在 capacity 中，不会超出数组长度
- (n - 1) & hash，当n为2次幂时，会满足一个公式：(n - 1) & hash = hash % n

**当我们传入的初始容量不是2的幂会怎么办？**

当我们传入不是2的幂的`initialCapacity`那么就会打破这个规则了吗，其实并不是

在构造器传入`initialCapacity`参数的时候，参数会被传给`tableSizeFor`方法调用，这个方法会把传入的参数转换成最接近的2的幂。

![image-20201203094945150](http://img.fosuchao.com/image-20201203094945150.png)

https://cloud.tencent.com/developer/article/1558000

### **DEFAULT_LOAD_FACTOR**

负载因子，默认是0.75

负载因子的作用就是判断当前哈希表是否需要扩容，比如说哈希表容量为16，乘于0.75等于12，那么就是当哈希表中的元素数量达到12个的时候，就会发生扩容操作。

**为什么是0.75？**

这个是专业的人员计算得出的，如果负载因子小了，那么会导致扩容操作过于频繁，如果负载因子大了，那么会导致哈希碰撞过多。

## 方法

分析一下一些比较重要的方法

### putVal

设置键值对的方法是put，而put内部调用的就是putVal方法。

![image-20201203100541548](http://img.fosuchao.com/image-20201203100541548.png)



### resize

扩容为原容量的两倍，并将存在的元素 放到新的数组上

![image-20201203100914389](http://img.fosuchao.com/image-20201203100914389.png)

### getNode

根据 hash 和 key 获取相应的 Node节点

![image-20201203101455460](http://img.fosuchao.com/image-20201203101455460.png)

### treeifyBin

链表转红黑树

![image-20201203102025847](http://img.fosuchao.com/image-20201203102025847.png)

如果哈希表的容量小于64的话，优先进行扩容，而不是转红黑树

## 红黑树

红黑树是一种自平衡的二叉查找树，比普通的二叉查找树效率更高，它可在 O(logN) 时间内完成查找、增加、删除等操作。

普通的二叉查找树在极端情况下可退化成链表，导致 增、删、查 效率低下。红黑树通过定义一些性质，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态，红黑树的性质定义如下。

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是 NIL 节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

红黑树的操作和其他树一样，包括查找、插入、删除等，其查找过程和二叉查找树一样简单，但插入和删除操作要复杂的多，这也是其 为保持平衡性 不会退化成链表 所付出的代价。红黑树为保持平衡性 所进行的操作主要有 旋转（左旋、右旋）和变色。



## 注意点

### 与 Hashtable 的比较

- Hashtable 使用 synchronized 来进行同步。
- HashMap 可以插入键为 null 的 Entry。
- HashMap 的迭代器是 fail-fast 迭代器。
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。

### resize

1.7 和 1.8