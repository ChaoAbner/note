# 大型网站系统与java中间件实践

## 初识分布式系统

### 分布式系统的意义

为什么使用分布式系统？下面从三个方面介绍其中原因

- 升级单机处理能力的性价比越来越低
- 单机处理能力存在瓶颈
- 处于稳定性和可用性的考虑

  ​	由摩尔定律我们知道：价格不变时，每隔18月，集成电路上可容纳的晶体管数目会增加一倍，性能也增加一倍。

![1571323794267](F:\typoraImg\1571323794267.png)

这是一种**垂直拓展**

​		垂直拓展的性价比低，对cpu的利用率低下，因此我们采用分布式系统的**横向拓展**。每台服务器不一定要有很高的配置，但是我们用数量来代替计算机性能的升级，有利于充分利用计算机的资源。



### 组成计算机的五要素

由冯 ‘ 诺依曼提出的计算机设计架构

​		组成计算机的基本元素包括`输入设备`、`输出设备`、`运算器`、`控制器`和`存储器`。存储器有分为了`内存`和`外存`。

![1571323983140](F:\typoraImg\1571323983140.png)

### 阿姆达尔定律

在多核时代，程序的并发和并行还能重要。通过阿姆达尔定律可以很好的看到。

![1571324377639](F:\typoraImg\1571324377639.png)

### 不同多线程模式

- 互不通信的多线程模式

  这种模式各个线程完成自己的工作，互不影响。

  ![1571325558687](F:\typoraImg\1571325558687.png)

- 基于共享容器协同的多线程模式

  某些场景下我们需要多个线程对共享数据进行处理。例如生产者和消费者的例子。有一个队列用于生产和消费。这个队列就是一个数据对象，多个线程并发访问这个队列。

  ![1571325551169](F:\typoraImg\1571325551169.png)

- 通过事件协同的多线程模式

  比如A、B两个线程，B线程的启动要通过A线程的状态或者事件发生之后才能发生。

  ![1571325688090](F:\typoraImg\1571325688090.png)



### 多进程模式

​		前面的多线程是在一个进程内共享了进程的内存空间。

​		而多个进程的内存空间是独立的，因此多进程之间的内存共享和交换数据的方式和多线程之间的方式不同。

​		多进程相对于单进程多线程的方式来说，资源控制会更容易实现。另外，多进程中的单个进程为题，不会造成整体的不可用。

​		多进程之间的共享数据，代价比多线程要大，会涉及序列化和反序列化（参考dubbo和zookeeper的原理）

### 网络IO实现方式

我们在实践中用的比较多的网络模型主要是以太网以及TCP/IP协议栈，当我们使用Socket进行网络通信开发时，我们会用到的三种方式是：BIO、NIO和AIO

- BIO方式

  阻塞方式来实现，Socket套接字需要使用一个线程来处理。当建立连接、读写操作有可能会阻塞。这种模式的好处就是简单。例子如简单的聊天程序。需要创建多个线程来处理这个工作。

  ![1571329976748](F:\typoraImg\1571329976748.png)

- NIO方式

  非阻塞方式，基于事件驱动思想，采用的是`Reactor`模式。可以在一个线程中处理多个Socket套接字的相关工作。`Reactor`模式在通信中的应用如下图

  ![1571330057937](F:\typoraImg\1571330057937.png)

- AIO方式

  异步IO，采用`Proactor`模式。AIO与NIO的差别是，AIO在进行读写操作时，只需要调用响应的read、write方法，并且需要传入CompletionHandler（动作完成时的处理器）；Proactor模式如下图。

  

![1571330202404](F:\typoraImg\1571330202404.png)

## 大型网站架构演进

### 单机构建网站

![1571367153951](F:\typoraImg\1571367153951.png)

### 单机负载告警，数据库与应用分离

不会产生其它什么问题，降低单机的负载。

![1571367206852](F:\typoraImg\1571367206852.png)

### 应用服务器告警，让服务器走向集群

产生的问题：

- 用户对应用服务器的访问选择问题，可以通过DNS来解决，也可以通过负载均衡设备来解决。通常用负载均衡来处理这个问题。
- Session问题。

![1571367358492](F:\typoraImg\1571367358492.png)

### 解决应用服务器变成集群后产生的Session问题

​		每次浏览器与web服务器的交互，由于HTTP协议是无状态的，需要基于HTTP协议支持会话状态（Sesstion State）的机制。这样就可以使Web服务器知道是这些请求是来自哪个会话。

​		会话开始时，服务器会分配一个SesstionID给浏览器，浏览器则通过Cookie来存储这个id。并且在下一次请求的时候带上这个id来告知服务器这个请求时是属于那个会话的。

​		若遇到禁用Cookie的情况，通常将SesstionID作为URL参数来解决。

​		当我们的应用服务器变成集群之后，问题就出现了，因为我们的Session是保存在单机上的，就会出现我们访问一台服务器，但是我们的回话数据保存在另一台服务器上的情况，导致我们的回话信息并不被服务器知道。

1. **Session Sticky**

   如果要保证同一会话的请求都在同一个web服务器上的话，需要让负载均衡器根据每次请求的会话标识来进行请求转发。这就是Session Sticky的方式。

   ![1571367964613](F:\typoraImg\1571367964613.png)

   **导致的问题：**

   - 如果有一台web服务器宕机或者重启，那么这台机器上的会话数据就会丢失，如果会话中有登录状态信息，那么用户就要重新登录了。
   - 会话标识是应用层的信息，负载均衡器要将同一个会话的请求都保存到同一台web服务器的话，就要到应用层解析（OSI模型第七层）。这个开销要比第四层的交换要大。
   - 负载均衡器变成了一个有状态的节点，要将会话保存在服务器上的映射。和无状态节点相比，内存开销要大很多。

2. **Session Replication**

   



![1571368407955](F:\typoraImg\1571368407955.png)

​		跟Session Sticky相比，Session Replication方式对负载均衡器没有那么多的要求。

​		但在某些场景下，**会造成一些问题**：

- 同步Session造成的带宽消耗很大，特别是机器数量多了的时候。

- 每台机器都要保存所有的session数据，造成对内存的消耗太大。

  这种方案适用于机器数量不太多，session数据量不太大的情况

**3.Session数据集中存储**

![1571368752914](F:\typoraImg\1571368752914.png)

​		当web服务器使用session数据时，就从这个集中存储session数据的地方来获取。存储的具体方式可以是数据库，也可以是使用其它分布式的存储系统。

**这个方式所导致的问题**：

- 读写session操作引入了网络操作。存在延时和不稳定性。不过通信基本发生在内网，问题不大。
- 如果存储session数据的继器或者集群有问题，就会影响我们的应用。

**4.Cookie Based**

​	通过Cookie来传递Session数据，由web服务器生成对应的Session数据。

​	不依赖外部系统，不存在延时。

![1571369101329](F:\typoraImg\1571369101329.png)

**造成的问题**：

- Cookie长度限制会限制session长度。
- 安全性。session本来是存储在服务端的，保存在客户端的cookie时就会出现安全性问题，通常我们需要对写入cookie的session数据进行加密处理。
- 带宽消耗。数据中心整体外部带宽的消耗。
- 性能影响。每次请求都带有session数据，需要处理的东西变多。

**对于大型网站来说，Session Sticky和Session数据集中存储是比较好的方案。**

### 采用数据库作为读库

数据访问大多都是读多写少，我们可以考虑读写分离的方式。

增加专门的读库来分担主库的读的压力。

![1571369526009](F:\typoraImg\1571369526009.png)

**造成的问题：**

- 数据复制的问题
- 应用对于数据源的选择问题

### 搜索引擎相当于读库

搜索引擎的结构如图

![1571375333160](F:\typoraImg\1571375333160.png)

结构跟读库差不多，只是构建索引的过程需要我们自己处理。

### 加速数据读取——缓存

#### 数据缓存

​		主要分担数据库读操作的压力。

​		一般我们在缓存中放的是“热”数据而不是全部数据，如果缓存不存在则从数据库读出数据后放入缓存。

​		还有一种方式就是在数据库的数据发生变化后，主动把数据放入缓存系统中。这样的好处就是，载数据变化时能够及时更新缓存中的数据，不会造成读取失效。这种方式一般用于全数据缓存的情况。

![1571375778480](F:\typoraImg\1571375778480.png)

#### 页面缓存

​		页面缓存用于web服务中，可以加速应用在响应请求时的数据读取速度。但是最终应用返回给用户的主要还是页面，有些页面或页面的一部分内容特别热，就可以对这些内容进行缓存。`ESI`就是针对这种情况的规范。

​		![1571376213565](F:\typoraImg\1571376213565.png)

​		apache中的模块会对请求的响应结果做处理，找到ESI标签，然后去缓存中获取这些ESI标签对应的内容，若内容不存在，则通过web服务器去渲染这些内容，并且把结果放入缓存中，用内容替换ESI标签，返回给客户的浏览器。

​	不过apache的ESI模块总要对响应结果做分析，然后在进行ESI的操作，如果在web服务器处理时就能直接把ESI的相关工作做完会是更好的选择。

​	![1571376477278](F:\typoraImg\1571376477278.png)

### 弥补关系型数据库的不足，引入分布式存储系统

​		常见的分布式存储系统有分布式文件系统，分布式Key-Value系统和分布式数据库。

​		分布式文件系统解决了大文件和小文件的问题

​		分布式Key-Value系统提供了高性能的半结构化的支持

​		分布式数据库提供一个支持大数据、高并发的数据库系统。

引入分布式存储系统的结构如下图

![1571376791093](F:\typoraImg\1571376791093.png)

## 服务框架

服务框架要解决的问题

![1571402050954](F:\typoraImg\1571402050954.png)

### 单机方式

实现一个计算器功能

![1571402108573](F:\typoraImg\1571402108573.png)

### 实现远程服务的调用客户端

需要把Calulator的接口抽象出来，然后把实现独立。

![1571402149869](F:\typoraImg\1571402149869.png)

调用端

![1571402182999](F:\typoraImg\1571402182999.png)

![1571402196804](F:\typoraImg\1571402196804.png)

### 实现服务端

​		在服务端，需要持续监听服务请求并且处理。获取请求数据后调用特定服务（`getServiceByNameAndVersion`），获取返回结果后反序列化再通过网络返回结果。

![1571402238249](F:\typoraImg\1571402238249.png)

### 服务调用端的设计与实现

![1571402726918](F:\typoraImg\1571402726918.png)

