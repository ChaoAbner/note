# Synchronized和Volatile

## Java内存模型（JMM）

​		介绍下面内容时，先了解一下Java内存模型，如下图

![1580311057467](F:\typoraImg\1580311057467.png)

​		在Java内存模型中有一个**主内存，用于储存J所有的变量**，而在线程内存（私有的工作内存）里面保存该线程的使用到的变量副本（该副本就是**主内存中该变量的一份拷贝**）。

### 线程与主存

线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存中读写

### 线程之间

线程之间的通信有两种方式：消息传递，共享内存。

在**共享内存**的并发模型里，线程之间**共享程序的公共状态**，线程之间通过**写-读内存**中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。

在**消息传递**的并发模型里，线程之间**没有公共状态**，线程之间必须通过明确的**发送消息**来显式进行通信，在Java中典型的消息传递方式就是**wait()和notify()**。

Java采用的是共享内存的线程通信方式，例子如下

- 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。
- 线程1对共享变量的修改，要想被线程2及时看到，必须经过如下2个过程：
    1、把工作内存1中更新过的共享变量刷新到主内存中
    2、将主内存中最新的共享变量的值更新到工作内存2中

### 可见性与原子性

可见性：

- 一个线程对共享变量进行修改的时候，其它线程可以及时的知道。

原子性：

- `num++`这个操作有三个步骤组成：

  1、取出num

  2、对num值+1

  3、将结果在赋给num（写入内存）

对于这种操作，我们则称为不是原子操作。即原子性是不能有多个操作，不可再分。

通常在多线程开发中，不常采用对num本身的改变方法（自增自减等）；

## 介绍

### synchronized

保证原子性和可见性

在Java内存模型中，synchronized规定，**线程在加锁时**，步骤如下

- 1、先清空工作内存

- 2、在主内存中拷贝最新变量的副本到工作内存

- 3、执行完代码

- 4、将更改后的共享变量的值刷新到主内存中
- 5、释放互斥锁。

及时将改变的变量刷到主存保证了可见性。

对该变量加锁即保证了原子性。

### Volatile

保证可见性，不保证原子性

​		Volatile实现内存可见性是通过`store`和`load`指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；而在读操作时，会加入一条load指令，即强迫从主内存中读入变量的值。但volatile不保证volatile变量的原子性

​		Volatile保证了可见性的特点，使得在设计模式中的**单例模式**起到很大作用，稍后举例。

## Synchronized和Volatile的比较

​    1）Synchronized保证内存可见性和操作的原子性
​    2）Volatile只能保证内存可见性
​    3）Volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。）
​    4）volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）.
​    5）volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符。
​      volatile本质是在告诉JVM当前变量在寄存器中的值是不确定的，使用前，需要先从主存中读取，因此可以实现可见性。而对n=n+1,n++等操作时，volatile关键字将失效，不能起到像synchronized一样的线程同步（原子性）的效果。

## 双重检查

双重检查（Double-Check）是单例模式中的一种实现，经常被使用。

```java
class Singleton{
    private volatile static Singleton instance;
    
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 不加volatile

​		如果不加volatile关键字的话，就无法保证变量的可见性，比如线程A首先进入了同步代码块，instance为null，故进行初始化，此时初始化的步骤分两步：1、为instance分配一块内存空间。2、将实例化的对象写入内存。A释放锁后，B进入同步代码块，此时判断instance不为空，即返回instance，但是可能因为instance的实例化过程没走完，所以返回的仍然是一个空对象（未被初始化）。

### 加了volatile

​		上面说了，volatile保证了可见性，即一个线程修改了变量后，对另外的线程能够立刻看见修改的值。对上面的例子来说就是，A实例化instance的过程变成了：1、将实例化的对象写入内存。2、将这块内存分配给instance。这就保证了线程B返回的instance是初始化好的，不会造成返回空对象的问题。

