# MySQL总结

1. #### 范式(最好记住几个例子)      

   - 第一范式(确保每列保持原子性)

     表：字段1、 字段2(字段2.1、字段2.2)、字段3 ......

     学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是。**如果有一列可以拆分，就应该再拆分**

   - 第二范式(确保表中的每列都和主键相关) 对记录的**惟一性**

     错误表：学号、课程号、姓名、学分;

     正确表：学生：`Student`(学号, 姓名)；课程：`Course`(课程号, 学分)；选课关系：`StudentCourse`(学号, 课程号, 成绩)。

   - 第三范式(确保每列都和主键列直接相关,而不是间接相关) 对字段的**冗余性**

     表: 学号, 姓名, 年龄, 学院名称, 学院电话

     因为存在**依赖传递**: (学号) → (学生)→(所在学院) → (学院电话) 。

     正确表：学生：(学号, 姓名, 年龄, 所在学院)；学院：(学院, 电话)。

2. #### 索引（索引的含义、优缺点）      

   提高查询效率的排好序的数据结构

   优点是可以提高**查询**的速度效率。

   缺点是1、降低了插入，更新，删除的效率。2、创建维护索引要消耗时间。3、占用了一部分物理内存。

3. #### b+树索引一页默认可以存储**16k**（可以一次将一页的数据放到内存中查找）

4. **innodb下幻读是如何在RR级别下被解决的？**

   innodb下的幻读是由**MVCC** 或者 **GAP 锁** 或者是**next-key lock** 解决的。

5. #### 索引的数据结构（底层）    

   - 二叉树
   - 红黑树
   - B树
   - 哈希表  

6. #### 索引为什么使用B+树不用B树

   b树和b+树的区别是，b树上的节点会存储索引和数据，但是b+树只有叶子节点上存储数据，这样一页的数16k的容量来说，b+树能存储更多的索引。

   另外，b+树的一个节点中的索引中间有个指针（默认占6个字节内存），用于指向下一块文件地址或索引对应字段的所有数据。

7. #### 索引为什么不用哈希

   **1.hash表只能匹配是否相等，不能实现范围查找**

   select * from xx where id > 23; 这时就没办法索引了

   **2.当需要按照索引进行order by时，hash值没办法支持排序**

   select * from xx order by score desc;如果score为建立索引的字段，hash值没办法辅助排序。

   **3.组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了阿和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，没办法支持部分索引**

   **4.当数据量很大时，hash冲突的概率也会非常大**

8. #### 索引为什么要用整形递增?

   整形比较方便，速度快。递增满足b+树的结构，由左向右添加节点。如果添加的字段索引是随机的，那么可能会破坏之前排序的结构，重新平衡改变树的结构，造成很大的性能损耗。

9. #### 索引的分类  

   **普通索引**（单个索引）

    ` CREATE INDEX mycolumn_index ON mytable (myclumn)`    

   **主键索引**

   它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候指定了主键，就会创建主键索引， CREATE INDEX不能用来创建主键索引，使用 ALTER TABLE来代替。

   `ALTER TABLE table_name ADD PRIMARY KEY ( column )`

   **唯一索引**：保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用，**比如name列已经存在了joker，当又要插入joker的时候，就会报错**。

    `　CREATE UNIQUE INDEX myclumn_cindex ON mytable(mycolumn)`

   **全文索引**：FULLTEXT索引用于全文搜索（搜索引擎）。只有InnoDB和 MyISAM存储引擎支持 FULLTEXT索引和仅适用于 CHAR， VARCHAR和 TEXT列。

   `ALTER TABLE table_name ADD FULLTEXT ( column )`

   **组合索引**

   `CREATE INDEX index_name ON table_name(col1,col2)`

   删除索引的语句

   `ALTER TABLE  mytable DROP INDEX indexname;	`

10. #### 聚簇索引与非聚簇索引      

   聚簇索引指的是索引指向即是数据。

```
非聚簇索引指的是索引指向的是一个方向，比如说数据的内存地址，然后再根据内存地址去查找数据。
```

11. #### 建立索引的考虑因素      

    1、建立索引的字段区分度要高，如果索引字段很多重复的话，说明区分度就不高，查询起来效率提升很少。

    2、设置的字段最好是整形递增的，类似id。因为这样才符合B+树的结构，如果使用类似UUID这样的随机字段作为索引可能会导致插入的时候造成索引结构严重改变的问题。随机IO严重。

    3、根据需要来建立索引

12. #### 使用索引的注意事项     

    （1）避免属性隐试转换 ， 如定义Moblie varchar  where Moblie =198989888会导致全表扫描；

    （2）查询的时候，索引不要进行运算（"name"+1=2 或者 max（name)=3）；

    （3）不要用SELECT *，填上需要查询的字段；

      (4)  **最左前缀原则**，条件因从最左边的索引开始，不能跳过中间的索引。

    （5)**少用or**

    （6）**禁止负向查询**： NOT、！=、<>、！<、！>、NOT IN、NOT LIKE，会导致全表扫描；

    （7）大表之间的join，**尽量缩小结果集之后再join**，否则会消耗较多的内存和CPU；

    （8）搜索**严禁左模糊或者全模糊**（like %XX, 或like %XX%），会导致全表扫描。

13. #### 事务特性（ACID）    

    **原子性**

    指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

    **一致性**

    指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。

    **隔离性**

    指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，**事务不会查看到中间状态的数据**。

    **持久性**

    指的是只要事务成功结束，它对数据库所做的更新就**必须永久保存下**来。**即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态**。

    

14. #### 事务隔离级别

    - 未提交读（read uncommit) 

      允许脏读，也就是可能读取到其他会话中未提交事务修改的数据

    - 提交读 (read commit) 

      只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)

    - 可重复读 (repeatable read) 可重复读。

      在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读

    - 串行读 (read serializable)

      完全串行化的读，每次读都需要获得**表级共享锁，读写相互都会阻塞**

    ==================================================================================== 隔离级别                                                脏读                            不可重复读                                        幻读

    ------

    未提交读（Read uncommitted）      可能                              可能                       						可能

    已提交读（Read committed）          不可能                          可能                        						可能

    可重复读（Repeatable read）          不可能                          不可能                     						可能

    可串行化（Serializable ）                  不可能                           不可能                    					不可能

    ====================================================================================

15. #### 多事务并发会造成的问题(脏读、不可重复读、幻读)

16. #### 读锁与写锁      

    读锁即使共享锁，写锁是排他锁。

    多个客户端可以共享读锁，一起读数据，不能修改数据。

    修改数据时，一个客户端获得了排他锁，其它客户端就不能再读或者写。

17. #### Mysql的工具分析      

    explain profile

18. #### MyBatis一级缓存      

19. #### MyBatis二级缓存      

20. #### Mybatis中的#和$的区别      

21. #### 高并发数据库设计（百万级数据库设计）      

22. #### 数据库优化      

23. #### 主从复制      

24. #### Mysql数据引擎的选用      

25. #### 数据库连接池     

26. #### **MySQL存储引擎MyISAM和InnoDB**

    存储引擎的概念是作用于**表**的。

    MyISAM引擎在数据表中有三个文件：**.frm(表的框架），.MYD(存储表中数据)，.MYI(存储表的索引)**，使用的是**非聚集索引**，即索引查到的叶子节点的数据对应的是数据所在的文件地址。**即找到.MYI文件中的索引指向的地址，找到对应.MYD文件中的数据。**

    InnoDB引擎则只有两个文件，.frm(表的框架），.IBD(存储表中**索引加数据**)，使用的是**聚集索引**

    **MyISAM只支持表锁，不支持行锁，锁粒度更小。InnoDB则都支持。**

    INNODB 以主键排序存储；聚集索引只能是主键，存储所有数据；二级索引包含主键键值

    ![1581992471045](F:\typoraImg\1581992471045.png)