# JVM总结

### 类加载机制，双亲委派模型的好处是什么

某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。

### JVM内存模型 

https://www.fosuchao.com/blog/article_17/

### GC中如何判断对象是否需要被回收（判断是否存活）

**1.引用计数算法(已被淘汰的算法)**

给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1;当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。

目前主流的java虚拟机都摒弃掉了这种算法，最主要的原因是它很**难解决对象之间相互循环引用**的问题。尽管该算法**执行效率很高**。

**2.可达性分析算法**
目前主流的编程语言(java,C#等)的主流实现中,都是称通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。如下图所示，**对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象**。
![1581682556512](F:\typoraImg\1581682556512.png)

可作为GC Roots的对象包括下面几种:

> - 虚拟机栈(栈帧中的本地变量表)中引用的对象。
> - 方法区中类静态属性引用的对象。
> - 方法区中常量引用的对象。
> - 本地方法栈中JNI(即一般说的Native方法)引用的对象。

### 被GC判断为”垃圾”的对象一定会回收吗（什么时候被回收）

即使在**可达性分析算法中不可达的对象,也并非是“非死不可”的**,这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡**,至少要经历两次标记过程**:如果对象在进行可达性分析后**1、发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)**

当 JVM 经过可达性分析法筛选出实效对象时，并不是马上清除，而是进行标记并判断是否回收：

1. 判断对象是否覆盖了 finalize() 方法

- 如果覆盖了 finalize() 方法，那么将 finalize() 放到 F-Queue 队列中
- 如果未覆盖该方法，则直接回收

1. 执行 F-Queue 队列中的 finalize() 方法
   由虚拟机自动建立一个优先级较低的线程去执行 F-Queue 中的 finalize() 方法，这里的执行只是触发这些方法并不保证会等待它执行完毕。如果 finalize() 方法作了耗时操作，虚拟机会停止执行并将该对象清除。
2. 对象销毁或重生
   在 finalize() 方法中，将 this 赋值给某一个引用，那么该对象就重生了。如果没有引用，该对象会被回收。

代码示例:

```java
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;
    
    public void isAlive() {
        System.out.println("yes,i am still alive:)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize mehtod executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();
        // 对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为finalize方法优先级很低,所以暂停0.5秒以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no,i am dead:(");
        }
        // 下面这段代码与上面的完全相同,但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为finalize方法优先级很低,所以暂停0.5秒以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no,i am dead:(");
        }
    }
}
```

SAVE_HOOK对象的finalize()方法确实被GC收集器触发过,并且在被收集前成功逃脱了。另外一个值得注意的地方是,代码中有两段完全一样的代码片段,执行结果却是一次逃脱成功,一次失败,这是**因为任何一个对象的finalize()方法都只会被系统自动调用一次,如果对象面临下一次回收,它的finalize()方法不会被再次执行,因此第二段代码的自救行动失败了。因为finalize()方法已经被虚拟机调用过,虚拟机都视为“没有必要执行”。(即意味着直接回收)**

#### 方法区的内存回收

Java 虚拟机规范中说不需要方法区实现垃圾收集，因为方法区中存放的都是一些生命周期较长的类信息、常量、静态变量。方法区就像是堆的老年代，每次垃圾回收只有少量垃圾被清除：

- 废弃的常量：
  当前系统中没有任何对象引用常量池中的该常量，则是废弃常量
- 废弃的类判断规则：
  该类所有实例都被回收；
  加载该类的 ClassLoader 已经被回收；
  该类对应的 Class 对象没有引用，也无法通过反射访问该类的方法。

### **强引用，软引用，弱引用和虚引用**

- **强引用：**普通存在， P p = new P()，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
- **软引用：**通过**SoftReference**类来实现软引用，在内存不足的时候会将这些软引用回收掉。
- **弱引用：**通过**WeakReference**类来实现弱引用，每次垃圾回收的时候肯定会回收掉弱引用。
- **虚引用：**也称为幽灵引用或者幻影引用，通过**PhantomReference**类实现。设置虚引用只是为了对象被回收时候收到一个系统通知。

### GC算法

##### 1. 标记 - 清除算法（Mark-Sweep）

最基础的收集算法是"标记 - 清除"算法，之所以说它是最基础的是因为它逻辑简单、使用简便，而且后续的收集算法大多基于这种算法的不足而优化的。

标记 - 清除算法分为两个阶段：

​	1、标记阶段：标记的过程就是前面的**可达性分析法**执行的过程。首先**遍历所有 GC Roots 对象**，对从 GC Roots 对象可达的对象都打上一个可达标识。这个可达标识一般记录在对象 header 中（一个对象一般包括对象头、实例数据、对齐填充三个部分），表示该对象可以被 GC Roots 访问。参考下图



![img](https:////upload-images.jianshu.io/upload_images/6762021-18c73d39d1889f60.png?imageMogr2/auto-orient/strip|imageView2/2/w/660/format/webp)

可以看到，上图 B、E、F、G、J、K 对象是可达对象，所以这些对象的对象头中就会记录可达信息。

​	2、清除阶段：清除阶段是对堆内存进行遍历，通过读取这些对象的 header 信息来获取对象是否标记可达。如果**未标记则表示这些对象没有引用，就可以进行回收**。



![img](https:////upload-images.jianshu.io/upload_images/6762021-d25f19b967f2cb94.png?imageMogr2/auto-orient/strip|imageView2/2/w/643/format/webp)

清除阶段

标记 - 清除算法主要不足有两个：

- 效率问题：标记和清除都需要遍历，**效率不高**；
- 空间问题：标记清除后会产生大量不连续的内存水平**，空间碎片太多**会导致大内存对象无法生成而频繁进行 GC。

##### 2. 复制算法

为了解决效率问题，复制算法出现了。

- 原理：将可用内存按容量大小分为大小相等的两块，每次只使用其中一块。当这一块内存使用完毕，就将存活的对象复制到另一块上，然后再把这一块所有的对象一次性清理掉。

- 图解：

  ![img](https:////upload-images.jianshu.io/upload_images/6762021-e98b6b3bff7d90ad..jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1099/format/webp)

  复制算法回收前

先将内存区域分为大小相等的两块，只使用其中一块，并标记可达对象。

![img](https:////upload-images.jianshu.io/upload_images/6762021-f2bf66915ef07b5d..jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1099/format/webp)

复制算法回收后

当一块内存使用完毕以后，将其中的可达对象复制到另一块，然后再一次性清除原理的内存空间。

- 优点：简答高效，内存相对整齐
- 缺点：
  1.需要两倍的内存空间
  2.如果对象存活率高，需要复制的对象比较多，产生效率问题。
- 优化：
  在新生代中，由于大量的对象都是"朝生夕死"，也就是说一次垃圾收集后存活对象较少，因此我们可以把内存划分为三块：Eden、Survior1、Survior2，大小比例为 8:1:1。分配内存时只使用 Eden + Survior1，当这里的内存将满时，JVM 会出发一次 MinorGC，清除掉废弃对象，并将存活对象复制到另一块 Survior2 中。那么接下来就使用 Eden + Survior2 进行内存分配。
  通过这种方式只需浪费 10% 的内存空间即可实现复制清除算法，同时避免了内存碎片的问题。

##### 3. 标记 - 整理算法

- 原理：标记过程与 "标记 - 清除" 算法相同，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉一端边界外的内存。

![img](https:////upload-images.jianshu.io/upload_images/6762021-6d5fc711588dd824..jpg?imageMogr2/auto-orient/strip|imageView2/2/w/575/format/webp)

回收前

![img](https:////upload-images.jianshu.io/upload_images/6762021-6dc3e99bf2e5338b..jpg?imageMogr2/auto-orient/strip|imageView2/2/w/587/format/webp)

回收后

- 优点：无需复制，保证效率。内存规整。
- 缺点：效率不如复制算法。

##### 三种算法排行

在了解了以上三种 GC 算法以后，作一个简单的排行：

**效率：**复制算法 > 标记 - 整理算法 > 标记 - 清除 算法（标记 - 清除会产生内存碎片，需要大内存时会出发新一轮 GC）。

**内存规整率：**复制算法 = 标记 - 整理 > 标记 - 清除。

**内存利用率：**标记 - 整理算法 = 标记 - 清除算法 > 复制算法。

##### 4. 分代收集算法

当前商业虚拟机的垃圾收集都采用 "分代收集" 算法，这种相当于结合以上几种算法进行结合。

- 原理：把 Java 堆分为新生代和老年代，根据各个对象的年代采用最合适的收集算法。
  针对**新生代的**对象，采取灵活比例的**复制算法**，只需要复制少量存活对象就可以完成收集。
  针对**老年代**的对象，因为这些对象存活率高，没有额外空间进行分配担保，必须使用 **标记 - 清除 或 标记 - 整理 算法**。

### 垃圾收集器（重点CMS，G1）

详情https://blog.nowcoder.net/n/4ccac0f84928482eaa7e9a65f39a277f

 JVM中的垃圾收集器主要包括7种，即**Serial，Serial Old，ParNew，Parallel Scavenge，Parallel Old以及CMS，G1收集器**。HotSpot虚拟机的垃圾收集器如下图所示：

![1582297125786](F:\typoraImg\1582297125786.png)

#### CMS（Concurrent Mark Sweep）收集器：

CMS收集器是**一种以获取最短回收停顿时间为目标**的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种老年代收集器，通常与**ParNew**一起使用。

**CMS的垃圾收集过程分为4步：**

- **初始标记**：需要“Stop the World”，初始标记仅仅只是**标记一下GC Root能直接关联到的对象**，速度很快。
- **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。
- **重新标记**：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。
- **并发清除**：和用户线程并发执行的，**基于标记结果来清理对象**。

![1582297218913](F:\typoraImg\1582297218913.png)

那么问题来了，**如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？**

答：不会的，在并发标记阶段其实还包括了一次并发的**预清理阶段**，虚拟机会主动**等待年轻代发生垃圾回收**，这样可以将重新标记对象引用关系的步骤放在并发标记阶段，有效降低重新标记阶段Stop The World的时间。



#### CMS垃圾回收器的优缺点分析：

CMS以**降低垃圾回收的停顿时间**为目的，很显然其具有并发收集，停顿时间低的优点。

**缺点主要包括如下：**

- **对CPU资源非常敏感**，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。
- 收集过程中会产生**浮动垃圾**，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。通过参数**-XX:CMSInitiatingOccupancyFraction**的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现**Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。
- **标记-清除方式会产生内存碎片**，可以使用参数**-XX：UseCMSCompactAtFullCollection**来控制是否开启内存整理（无法并发，默认是开启的）。参数**-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。

接下来，我们先看下上边介绍的浮动垃圾是怎么产生的吧。

**浮动垃圾：**

由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了**“Floating Garbage”**，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，**并发收集器一般需要20%的预留空间**用于这些浮动垃圾。



#### G1（Garbage-First）收集器：

G1收集器将新生代和老年代取消了，取而代之的是**将堆划分为若干的区域**，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。

通过**将JVM堆分为一个个的区域（region）**,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的region。**

**G1收集器的特点：**

- **并行与并发**：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。
- **分代收集**：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。
- **空间整合**：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。
- **可预测的停顿**：能够建立可以预测的停顿时间模型，预测停顿时间。

**和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：**

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

其中，筛选回收阶段首先对各个Region的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。



**解析：**

这块关于垃圾回收器的知识点相对较多，我们重点介绍了CMS垃圾收集器，并且**CMS也确实是我们服务中最常使用的垃圾收集器**。利用CMS并发标记和清理的特性，**可以有效降低用户的停顿时间，对于服务的稳定性有一个非常显著的提升**。通常，作者本人设置的JVM启动参数如下，学习了上边的内容，聪明的你一定可以明白设置的含义啦。

```bash
`JAVA_OPTS=``"-Xms4096m –Xmx4096m -XX:NewRatio=2 -XX:SurvivorRatio=8 -Xloggc:/home/work/log/serviceName/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=10 "`
```

### Java中引用的种类

Java中根据生命周期的长短，将引用分为4类。

1. **强引用**
   我们平时所使用的引用就是强引用。
   A a = new A();
   也就是通过关键字new创建的对象所关联的引用就是强引用。
   **只要强引用存在，该对象永远也不会被回收。**

2. **软引用**
   只有当堆即将发生OOM异常时，JVM才会回收软引用所指向的对象。
   软引用通过SoftReference类实现。
   软引用的生命周期比强引用短一些。

3. **弱引用**
   只要垃圾收集器运行，弱引用所指向的对象就会被回收。
   弱引用通过WeakReference类实现。
   弱引用的生命周期比软引用短。

4. **虚引用**
   虚引用也叫幽灵引用，它和没有引用没有区别，无法通过虚引用访问对象的任何属性或函数。
   一个对象关联虚引用唯一的作用就是在该对象被垃圾收集器回收之前会受到一条系统通知。
   虚引用通过PhantomReference类来实现。

### 类的加载过程

​		类从被加载到**虚拟机内存中开始，到卸载出内存为止**，它的**整个生命周期**包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。

![1581686074597](F:\typoraImg\1581686074597.png)

**加载**（通过类加载器）
加载主要是将.class文件（并不一定是.**class**。可以是**ZIP**包，网络中获取）中的**二进制字节流读入到JVM中**。
在加载阶段，JVM需要完成3件事：
1）通过类的全限定名获取该类的二进制字节流；
2）将字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3）在**内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口**。

**验证**
验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。
验证阶段会完成以下4个阶段的检验动作：
1）文件格式验证
2）元数据验证(是否符合Java语言规范)
3）字节码验证（确定程序语义合法，符合逻辑）
4）符号引用验证（确保下一步的解析能正常执行）

**准备**
准备是连接阶段的第二步，主要为**静态变量在方法区分配内存，并设置默认初始值**。

**解析**
解析是连接阶段的第三步，是虚拟机将**常量池内的符号引用替换为直接引用的**过程。

**初始化**
初始化阶段是类加载过程的最后一步，主要是根据程序中的赋值语句主动为类变量赋值。
注：
1）当有父类且父类为初始化的时候，先去初始化父类；
2）再进行子类初始化语句。

参考连接https://blog.csdn.net/ns_code/article/details/17881581

### 类加载器

**类加载器实现的功能是即为类加载阶段获取二进制字节流的时候。**

JVM提供了以下3种系统的类加载器：

**启动类加载器**（Bootstrap ClassLoader）：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。
**扩展类加载器**(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
**应用程序类加载器**(Application ClassLoader)：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。
类加载器之间的层次关系如下：

![1581686612219](F:\typoraImg\1581686612219.png)

类加载器之间的这种层次关系叫做双亲委派模型。

#### 双亲委派机制

双亲委派模型要求除了顶层的启动类加载器（Bootstrap ClassLoader）外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不是以继承关系实现的，而是用组合实现的。

**双亲委派模型的工作过程**
如果一个类接受到类加载请求，他自己不会去加载这个请求，而是将这个类加载请求委派给父类加载器，这样一层一层传送，直到到达启动类加载器（Bootstrap ClassLoader）。
只有当父类加载器无法加载这个请求时，子加载器才会尝试自己去加载。

**双亲委派模型的代码实现**
双亲委派模型的代码实现集中在java.lang.ClassLoader的loadClass()方法当中。
1）首先检查类是否被加载，没有则调用父类加载器的loadClass()方法；
2）若父类加载器为空，则默认使用启动类加载器作为父加载器；
3）若父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass() 方法。

```java
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    //1 首先检查类是否被加载
    Class c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
             //2 没有则调用父类加载器的loadClass()方法；
                c = parent.loadClass(name, false);
            } else {
            //3 若父类加载器为空，则默认使用启动类加载器作为父加载器；
                c = findBootstrapClass0(name);
            }
        } catch (ClassNotFoundException e) {
           //4 若父类加载失败，抛出ClassNotFoundException 异常后
            c = findClass(name);
        }
    }
    if (resolve) {
        //5 再调用自己的findClass() 方法。
        resolveClass(c);
    }
    return c;
}

```

#### 类加载器的职责：

- **全盘负责：**

当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。

- **父类委托：**

类加载机制会先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。

父类委托机制是为了**防止内存中出现多份同样的字节码，**保证java程序安全稳定运行。

- **缓存机制：**

缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。

### java中会存在内存泄漏吗

 		Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露

​		对象都是有生命周期的，有的长，有的短，**如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露**。我们举一个简单的例子：

```java
public class Simple {
 
    Object object;
 
    public void method1(){
        object = new Object();
    //...其他代码
    }
}
```

  	 这里的object实例，其实我们期望它只作用于method1()方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object对象所分配的内存不会马上被认为是可以被释放的对象，只有在Simple类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。解决方法就是将object作为method1()方法中的局部变量。当然，如果一定要这么写，可以再后面将`object = null`；

#### 单例模式导致的内存泄露

​    单例模式，很多时候我们可以把它的生命周期与整个程序的生命周期看做差不多的，所以是一个长生命周期的对象。如果这个对象持有其他对象的引用，也很容易发生内存泄露。

### JVM常用内存调优命令

 JVM在内存调优方面，提供了几个常用的命令，分别为**jps，jinfo，jstack，jmap以及jstat命令**。分别介绍如下：

- **jps：**主要用来输出JVM中运行的进程状态信息，一般使用jps命令来**查看进程的状态信息，包括JVM启动参数**等。
- **jinfo：**主要用来观察进程运行环境参数等信息。
- **jstack：**主要用来查看某个Java进程内的线程堆栈信息。**jstack pid** 可以看到当前进程中各个线程的状态信息，包括其持有的锁和等待的锁。
- **jmap：**用来查看堆内存使用状况。**jmap -heap pid**可以看到当前进程的堆信息和使用的GC收集器，包括年轻代和老年代的大小分配等
- **jstat：**进行实时命令行的监控，包括堆信息以及实时GC信息等。可以使用j**stat -gcutil pid 1000**来每隔一秒来查看当前的GC信息。

### 如何排查一个线上的服务异常？

- **检查当前进程的JVM启动参数**，查看内存设置是否存在明显问题。
- **查看GC日志**，看**GC频率**和时间是否明显异常。
- 查看当前进程的状态信息top -Hp pid，包括线程个数等信息。
- **jstack pid查看当前的线程状态，是否存在死锁**等关键信息。
- **jstat** -gcutil pid查看当前进程的**GC情况**。
- **jmap** -heap pid查看当前进程的**堆信息**，包括使用的**垃圾收集器**等信息。
- 用**jvisiual**工具打开dump二进制文件，分析是什么对象导致了**内存泄漏，定位到代码处**，进行code review。

一般情况下，我们在测试环境上线新服务的时候，应该重点关注并且查看当前新服务的内存使用以及回收情况，避免新服务种出现内存异常导致服务崩溃的现象发生。

### JDK8中在内存管理上的变化

JDK8中出现了**元空间代替了永久代**。元空间和永久代类似，都是对**JVM规范中方法区的实现**。**区别**在于**元空间并不在虚拟机**中，而是使用**本地内存，**默认情况下元空间的大小仅受本地内存限制，也可以通过**-XX：MetaspaceSize指定元空间大小。**

**为什么要使用元空间代替永久代？**

字符串在永久代中，容易出现性能问题和内存溢出的问题。类和方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出。使用元空间则使用了本地内存。