# Java多线程总结

### Synchronized和Lock

synchronized是Java的关键字，当它用来**修饰一个方法或者一个代码块**的时候，能够保证在同一时刻最多只有一个线程执行该段代码。

JDK1.5以后引入了**自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能**。

Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

常用实现Lock接口的类：ReentrantLock，ReentrantReadWriteLock

**主要相同点**：Lock能完成synchronized所实现的所有功能
主**要不同点**：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放

### volatile关键字

volatile关键字是用来保证**有序性**和**可见性**的。这跟Java内存模型有关。

比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，**编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率**。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有**happens-before规则**，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；

有序性实现的是通过插入内存屏障来保证的。

可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。

### Syncronized修饰静态方法和修饰成员方法，锁住了什么

synchronized修饰静态方法以及同步代码块的synchronized **(类.class)用法锁的是类**，线程想要执行对应同步代码，需要获得类锁。
synchronized修饰成员方法，线程获取的是当前调用该方法的**对象实例的对象锁**。

### 线程从创建到死亡的几种状态都有哪些

1. **初始**( new )：新创建了一个线程对象。

2. **可运行**( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。

3. **阻塞**( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：
   (一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。
   (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。
   (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态

   ![1581590878121](F:\typoraImg\1581590878121.png)

   

4. **等待**（waiting)

   ![1581590478529](F:\typoraImg\1581590478529.png)

5. **超时等待**（TIMED_WAITING)

   ![1581590444771](F:\typoraImg\1581590444771.png)

6. **死亡**( terminated)：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。

### 可重入锁怎么实现的

每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如**果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增**。当线程**退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁**。

**如何排查死锁？**

​		死锁就是两个或者多个线程之间相互抢占资源，但是又不释放自己持有的资源所造成的一种相互等待的现象。

​		排查死锁的方式：jdk自带的**jstack** + pid（命令行），通过jps获取进程号pid

**如何保证线程顺序执行？**

​		1、可以使用**join**，join可以让主线程进行等待（底层就是调用**wait**方法），举个下图的例子，比如t1正在执行，join了之后让main等待，知道t1执行完了才去执行t2，依次类推。

![1582254187874](F:\typoraImg\1582254187874.png)

​		2、juc包中的countDownLatch等

### 线程池

线程池的基本组成如下图：

重点是**ThreadPoolExecutor**

![1582255743459](F:\typoraImg\1582255743459.png)

**线程池参数**

![1582256650512](F:\typoraImg\1582256650512.png)

![1582256671245](F:\typoraImg\1582256671245.png)

比如设置核心池线程数是5，任务队列数是5，最大线程数是10，那么当线程超过5个的时候，新的线程会被放到任务队列中，知道任务队列也被放满的时候，那么接着增加核心池中的线程数，知道最大线程数10的时候（核心池10个，队列5个），如果再有增加，则通过响应的饱和策略来处理。如果没有设置策略，则会抛出拒绝异常。

### Java中有几种线程池？并且详细描述一下线程池的实现过程

- **newFixedThreadPool**创建一个**指定工作线程数量的线程池**。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。
- **newCachedThreadPool**创建一**个可缓存的线程池**。这种类型的线程池特点是：
  1). 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
  2). 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
- **newSingleThreadExecutor**创建一个**单线程化的Executor**，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。
- **newScheduleThreadPool**创建一个**定长的线程池**，而且支持定时的以及**周期性的任务**执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)