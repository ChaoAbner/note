参考https://kb.cvte.com/pages/viewpage.action?pageId=200956106的设计方案

这里给出进一步的方案设计

## 鉴权方案时序图

![设备鉴权方案_3](http://img.fosuchao.com/设备鉴权方案_3.png)

## 安全设计

鉴权端在获取token的时候做了签名校验机制，因此需要appSecret的存在，用于在设备端生成签名

业务端在收到设备端获取token的请求的时候，需要自行判断设备端请求的真实性，校验通过后，才可以调用鉴权服务获取appSecret

### 签名校验机制

设备端通过时间戳(ts)，设备唯一码(sn)，appSecret(appSecret)，**按顺序拼接**成url参数的形式，示例如下：

![image-20201210151518471](http://img.fosuchao.com/image-20201210151518471.png)

**然后对string进行MD5或者SHA-256等不可逆算法进行运算，这里使用MD5**

![image-20201210151537865](http://img.fosuchao.com/image-20201210151537865.png)

运算得到的结果，就是签名(sign)，然后我们请求接口的时候，带上这个签名进行请求即可

对于上面的接口的请求参数就是：

![image-20201210151645481](http://img.fosuchao.com/image-20201210151645481.png)

### 请求获取appSecret的好处

appSecret的设计就是保密传输，并且在不主动交给第三方或者存储在代码中的情况下，拥有极高的安全性。

### 为什么可以重置appSecret

因为网络传输没有绝对的安全，参考网上开放平台（微信、阿里..）的都建议为了充分保障应用安全，建议定期重置secret，所以提供重置appSecret的服务

### appSecret的传输

每个C端产品或者独立应用都有一个唯一的appId，同时在后台也对应各自一个appSecret，如何保证appSecret能够安全的传到设备端是一个很重要的问题

因为每个产品有对应的设备信息，这个平台服务不做判断，而是由各个产品服务中自行根据设备的特征信息进行判断，确保设备的真实性，否则appSecret有被盗取的风险

确定了设备真实性后，就可以根据appId调用鉴权服务中的获取appSecret的服务了，鉴权服务读数据库拿到对应应用的appSecret之后，会通过对称加密（AES）对appSecret加密，其中会使用appId作为随机数去生成密钥，具体服务端与客户端交互的流程如下：

![appSecret传输流程_1](http://img.fosuchao.com/appSecret传输流程_1.png)

#### 测试微信公众平台appSecret的传输

登录微信公众平台，点击侧边栏开发中的基本配置

![image-20201210165915085](http://img.fosuchao.com/image-20201210165915085.png)

点开后可以看到页面中的appSecret选项，这是不可以直接查看的，第一次进入通过管理员微信扫码可以查看，查看后微信要求开发者记住这个appSecret的信息，之后刷新页面不会再传输此appSecret信息，如果忘了只能通过管理员再次扫码重置。

![image-20201210170006534](http://img.fosuchao.com/image-20201210170006534.png)

测试点击重置，管理员微信扫码后输入密码即可以看到发送了重置appSecret的**https请求**

![image-20201210170215916](http://img.fosuchao.com/image-20201210170215916.png)

并且在响应中发现可以直接查看服务器返回的appSecret

![image-20201210170325421](http://img.fosuchao.com/image-20201210170325421.png)

#### **结论**

我们可以在响应中看到原始数据，说明微信并没有对appSecret进行加密，但是因为https的传输是加密的，这些数据在网络传输的过程中也是加密传输的，只要客户端不要相信第三方的证书，使用https是可以保证传输数据的安全性的

如果接口使用的是https，那么其实不用在业务中再进行加密，直接给https加密就行了，可以省去加密的步骤，不过微信传输appSecret是基于用户登录状态并且后台要对密码等参数进行校验的

因此所以我们返回appSecret的时候用appId与appSecret再进行一次对称加密，到客户端再加密得到appSecret，再依靠客户端的代码混淆，可以保证较大程度的appSecret传输安全

## http和https的安全性测试

### http安全测试

测试swqa登录，http://swqa.gz.cvte.cn/

通过**ping swqa.gz.cvte.cn**拿到ip地址，然后在wireshark上进行抓包分析，这边测试用户登录的场景

在网站上登录后，通过过滤可以看到登录的POST请求

![image-20201211171211025](http://img.fosuchao.com/image-20201211171211025.png)

点击查看传输的内容

![image-20201211171454100](http://img.fosuchao.com/image-20201211171454100.png)

可以看到swqa登录的时候用户名和密码都是进行明文传输的，在网络传输的过程中，能被轻易的获取。

### https安全测试

在https://home.cvte.com上进行登录测试，可以发现抓包的数据连请求路径都看不到，数据都是通过加密过的

![image-20201211173429050](http://img.fosuchao.com/image-20201211173429050.png)

### 结论

如果接口是使用HTTPS协议的，可以极好的保证数据传输的安全。

**通过以上的设计和测试，可以保证我们的appSecret和设备唯一标识的传输是安全的，关键就是业务端对于设备真实性的校验**

## 设备真实性的校验

校验设备的真实性是很必要的，防止别人知道我们获取appSecret的方式后，直接通过appId进行获取，导致appSecret泄露，判断设备的sn是比较好验证真实性的方法，也可以根据一些版本参数的信息来判断

### 通过设备的sn来判断

在获取appSecret的时候，设备端获取到sn，作为参数一起请求业务端，业务端根据sn查询设备信息做校验

#### 哪里查询

1. 设备的信息统一保存在DSS，业务端调用DSS接口查询设备信息

> 目前设备的信息不自动保存在DSS，取决于激活后信息是否选择保存在DSS平台

2. 保存在业务库，各个业务端自行去查询设备信息

**注意点**

这里也需要区分旧设备和新设备，如果是旧设备则没有保存sn和设备信息，可以通过判断设备的版本号来区分

## Token存储设计

Token存储的方案罗列了一下几种：

1. 数据库存储
2. 本地内存储存（HashMap）
3. Redis存储

### 数据库存储

采用数据库存储，则需要设计一个用于保存设备Token的表，假设为**t_divice_token**，最简单的表结构如下：

![image-20201210163406882](http://img.fosuchao.com/image-20201210163406882.png)



**优点：**

1. 传统，数据不会丢失
2. 不会被Token数量太多所影响

**缺点：**

1. 频繁操作导致性能问题，速度慢
2. 需要在程序中判断过期时间

### 本地内存储存

本地内存存储，最简单的就是使用HashMap来存储

我们可以使用下面的存储结构来存储不同设备与Token的关系：

![image-20201210161801647](http://img.fosuchao.com/image-20201210161801647.png)

进行Token校验的时候，根据sn从map中取出响应的Token，并且判断时间是否过期，从而返回相应的结果给业务进行判断处理，**由于我们的系统是分布式系统，每个服务请求可能打到不同的服务器上，所以这个方案不适用。**

**优点：**

1. 开发方便，无须使用其他数据库存储服务
2. 读取，写入速度快

**缺点：**

1. 使用HashMap占用JVM的内存，如果设备量很多，占用内容过大，会导致OOM
2. 如果鉴权服务器断电，则会导致所有Token丢失
3. 判断过期后，要清除响应的key，操作麻烦
4. 分布式系统本地存储不一致

### Redis存储

对于存储Token的需求，在分布式场景下最常见也是最好用的就是使用Redis进行存储

**Redis的特性**

1. 读写速度快
2. 有过期策略
3. 分布式缓存系统
4. ...

**具体存储方法**

使用设备唯一码sn作为key，Token作为value，同时设置对应的过期时间

当请求Token校验的时候，根据sn查询Redis中对应的Token，如果查找不到，自然就说明Token已经过期了，不需要再额外判断时间是否过期了

同时，我们有需要给Token续命的场景，因为某些设备可能访问业务比较频繁，如果Token很快过期了，又要重新进行获取，比较麻烦，所以我们可以根据不同的应用业务要求，给对应的Token进行续命，只需要计算好下一次的过期时间，然后更新到Redis就行了，非常方便

![image-20201210165137991](http://img.fosuchao.com/image-20201210165137991.png)

**优点：**

1. 读写快
2. 适用于分布式场景
3. 符合业务需求，开发方便

**缺点：**

1. 调用业务的设备数量多的时候会占用较多内存，不过这些占用对于Redis来说可以忽略不计，何况还有过期策略

### 结论

通过上面对各个存储方式的分析，最终采用Redis存储Token的方案。

## 防重放

假设我们的Token信息和请求业务的链接被第三方获取到了，那么第三方可以很轻易的通过相同的链接请求业务数据，如果没有防止接口重放攻击，那么之前做的努力都无济于事

### 解决方案

1. 时间戳参数防重放
   1. 客户端生成请求时间戳
   2. 使用服务端时间戳加设备端时间戳差值生成请求时间戳
2. Redis保存请求链接，保证请求的唯一性

#### 时间戳参数防重放

**设备端生成**

设备端在获取到了Token之后，进行业务请求，每次请求都会携带时间戳参数（ts）

后端可以通过这个设备端传的时间戳与当前服务器时间进行差值判断，比如我们设定差值不超过5分钟，即获得的差值超过5分钟的请求都会判断为过期请求从而被抛弃

简单的程序逻辑如下：

![image-20201210171854870](http://img.fosuchao.com/image-20201210171854870.png)

#### 前提

**采用这种解决方案的前提是设备端的时间与服务端误差很小**

- 如果我们的设备销往了国外的话，时区改变，对应的时间戳也就跟服务端相差很大；
- 如果用户修改了本地的系统时间，设备端获取时间则是获取到被修改后的时间，导致参数根本不可用；
- 对于用户修改系统时间的情况，如果在联网的情况下，并且用户开启了通过网络获取时间的选项，那么可以通过请求网络时间来生成时间戳，但是如果用户关闭了通过网络获取时间的选项，也无法使用这个办法

因此客户端直接生成时间戳并不可靠



**使用服务端时间戳加设备端时间戳差值生成请求时间戳**

具体生成流程如下：

![设备端时间戳生成方案_1](http://img.fosuchao.com/设备端时间戳生成方案_1.png)

**优点：**

可以避免设备端生成的时间戳不确定的风险

**缺点：**

生成的时间戳受网络延迟的影响，请求的时间越长，生成的时间戳越滞后

这种解决方案可以防止第三方拿到一个链接和Token信息后，可以在Token有效期一直访问我们的数据接口，虽然在一定时间内仍然可以访问，但是可以很大程度避免接口被重放

#### Redis保存请求链接，保证请求的唯一性

这种方法非常的简单暴力，对于每个请求业务的链接我们都保存在Redis中，并且设置一个较短的过期时间（比如设置到Token过期的时间）

对每个请求都进行判断，判断当前请求的链接是否存在于Redis中，如果存在的话，直接拒绝调用即可

**优点：**

严格校验，一段时间内不能让同一个链接重放

**缺点：**

如果短时间内请求很多的话，很占用内存

### 结论

权衡上面的方案，最终选择**使用服务端时间戳加时间戳差值生成请求时间戳**的方案来防止重放

## 设备端生成唯一标识

目前我们的C端产品和独立应用的设备都是Android系统

基于目前的情况，设计下列针对安卓系统的获取设备唯一标识的方案

- Serial Number, SN(设备序列号)
- Mac 地址

### Serial Number

获取设备序列号不需要权限，但是有一定的局限性，在有些手机上会出现垃圾数据，比如红米手机返回的就是连续的非随机数

### Mac地址

如果使用Mac地址最重要的一点就是手机必须具有上网功能

在Android6.0以后 google 为了运行时权限对getMacAddress()；作出修改通过该方法得到的mac地址永远是一样的，但是可以其他途径获取。

### 确定唯一性

Serial Number（sn）和Mac地址都是保证每个设备都唯一的，它们都是保存在同一块磁盘分区的，对于我们的设备来说，如果需要篡改则必须返厂，一般用户是无法修改的，所以我们可以认可它们的唯一性和稳定性。

### 生成方案

因为Serial Number和Mac地址都是保证唯一的，所以我们直接选择使用Serial Number作为生成设备唯一码

**如果Serial Number为空的情况，设备端判断为空后，不能发送请求，同时鉴权端也会对Serial Number的合法性做校验，不允许Serial Number为空的情况出现。**

示例：

> 原始设备唯一码（init_sn），最终用于传输的设备唯一码：（sn）

获取设备唯一码

![image-20201211160615850](http://img.fosuchao.com/image-20201211160615850.png)

生成用于传输的设备唯一码

![image-20201211160628426](http://img.fosuchao.com/image-20201211160628426.png)

**我们最终生成的用于传输的sn是由获取的原始设备唯一码（init_sn）经过MD5算法生成的（如果校验设备真实性使用sn的话，则不需要在设备端加密，而是在业务端进行加密）**

**原因：**

1. 为了保证sn的唯一性

2. 为了后台能使用固定长度的字段进行存储
3. sn的保密性

## 参考链接

[签名机制](https://open.taobao.com/docV3.htm?spm=a219a.7386797.0.0.3e64669asajVgx&source=search&docId=112812&docType=1#ss3)

[android获取设备唯一标识完美解决方案的思考以及实现方式](https://www.jianshu.com/p/471df87af749)

