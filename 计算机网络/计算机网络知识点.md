# 计算机网络知识点

## 名词类

### ADSL

ADSL属于DSL技术的一种，非对称数字用户环路，上行下行速率不同，用现有电话线，不需重新布线，互相之间不干扰

### IEEE（美国电子电气工程师协会）

局域网（LAN）的结构主要有三种类型：以太网（Ethernet）、令牌环（Token Ring）、令牌总线(Token Bus)以及作为这三种网的骨干网光纤分布数据接口（FDDI）。它们所遵循的都是IEEE（美国电子电气工程师协会）制定的以802开头的标准。

### 交换机和路由器

- 交换机可以隔离冲突域。是基于物理网卡地址的设备。交换机网络如果出问题，就会引发广播风暴。
- 路由器才能隔离广播域，当然冲突域也能隔离。是基于网络逻辑地址的设备。

### 时延

**发送时延**：结点在**发送数据时使数据块从结点进入到传输媒体所需的时间**，也就是从数据块的第一个比特开始发送算起，到最后一个比特发送完毕所需的时间。发送时延又称为传输时延。发送时延=数据帧长度/发送速率

**传播时延**：从**链路起点到终点传播所需要的时间**。传播时延=d/s（其中d为起点和终点距离，s为传播速率）

**处理时延**：进行**转发处理所花费的时间**，如首部处理、差错检验等

**往返时延**：从**发送端发送数据开始，到发送端接收到来自接收端的确认**，总共经历的时延。

### 端口

公共服务保留端口： 0-1023 

注册端口： 1024-49151 

动态或私有端口： 49162-65535

### 网络协议三要素

1. 语义：规定通信双方彼此“讲什么”，即确定协议元素的类型，如规定通信双方要发出什么控制信息，执行的动作和返回的应答。
2. 语法：规定通信双方彼此“如何讲”，即确定协议元素的格式，如数据和控制信息的格式。
3. 交换规则：规定了信息交流的次序。

### OIS/RM

开放系统互连参考模型 (Open System Interconnect 简称OSI）

由ISO提出，ISO是International Organization for Standardization的简称，即“国际标准化组织”

## 收藏问题

### 计算机与局域网连接，至少需要具有的硬件是

网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口

### 数据打包的5个转换步骤

从应用层到物理层依次为：

应用层、表示层、会话层：数据

传输层：数据段

网络层：数据包、

数据链路层：数据帧

物理层：比特

### 地址中属于网络地址的是？

192.168.0.64/25
192.168.0.32/27

x.x.x.x/y 就表示以前y位二进制数作为网络号。那么正确的网络号应该是第y为后的二进制数都为0，对吧。

192.168.0.64/25 = 11000000.10101000.00000000.01000000

最后一组数0 1000000，第26位有个1，A错。

192.168.0.32/27 = 11000000.10101000.00000000.00100000

最后一组数001 00000，第27位后的数全为0，B对。

## 重点

### 三次握手

![img](F:\typoraImg\408769_1450324909404_B54E448D8BD89C4B4E0090C0E199CC37.png)

### 四次挥手

![img](F:\typoraImg\408769_1450324934939_34C80DB83FD510D8709597B587454325.png)

### 粘包半包

​		粘包半包的问题是发生在**应用层**的，TCP传输层不存在这种问题，TCP传输的是字节，并且传输的速度是跟网络有关。

![1582268350944](F:\typoraImg\1582268350944.png)



### UDP如何实现可靠传输

UDP不属于连接层协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和一些数据在传输时，即使丢失少量的包也不会对结果造成太大的影响。

在传输层无法实现可靠传输，只能在应用层实现，可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

- 1、添加seq/ack机制，确保数据发送到对端
- 2、添加发送和接收缓冲区，主要是用户超时重传。
- 3、添加超时重传机制。

有如下开源程序利用udp实现了可靠的数据传输。分别为**RUDP、RTP、UDT**。

OSI七层模型、五层模型、TCP/IP四层模型      

七层：应用层、表示层，会话层、传输层、网络层、数据链路层、物理层

五层：应用层、传输层、网络层、数据链路层、物理层

四层、应用层、传输层、网际层、网络接口层

![1582363942858](F:\typoraImg\1582363942858.png)

​    三次握手(为什么不是两次、为什么不是四次)   

**我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功**   

1、客户端向服务端发送SYN=1和随机数seq=x，状态变成SYN-SENT等待匹配请求

2、服务端接收到客户端的连接包，将SYN=1，随机数seq=y，ACK=1，ack=x+1返回客户端，状态变成SYN-REVDS（SYN接收状态）

3、客户端判断ack是否等于x+1和ACK是否=1，相等则发送ACK=1，ack=y+1，seq=x+1服务端接受到后判断ack是否等于y+1，是即建立连接完成。状态变成ESTAB-LISHED

如果只用两次就建立连接的话，服务器可能收到的是已经失效的报文。

比如说我发微信约饭，一条信息一直在转圈圈（在网络节点中长时间的滞留），然后我又发了一条，接收方成功收到了，但是过了一段时间，那个信息又成功到了接收方那里，如果接收方重新确认一次的话，吃饭就被放鸽子了。

ACK和ack的区别：

- **TCP 包的 ACK 标志位（1 bit） 被置成了 1**
- **TCP 包的确认号（acknowledgement number ） 的值为 x+1**

​    四次挥手（为什么是四次挥手不是三次） 

**我要和你断开连接；好，断吧；我也要跟你断开连接；好，断吧。**

1、client端发送FIN=M给Server端，状态变成FIN_WAIT_1。

2、Server端接收FIN，发送确认标志ACK=M+1，状态变成CLOSE_WAIT，此时TCP链接处于半关闭状态，即client端已经没有要发送的数据了，但Server端若发送数据，则client端仍要接收。此时client端状态为FIN_WAIT_2

3、Server端发送断开信号FIN=K，用来关闭Server端到client端的数据连接，server进入LAST_ACK。

4、client端接收FIN，返回应答ACK=1，ack=K+1给Server，确认序号为K+1，Server进入CLOSED。

TCP标志位和各种标志代表什么

- **SYN**(synchronous建立联机)
- **ACK**(acknowledgement 确认)
- PSH(push传送)
- **FIN**(finish结束)
- RST(reset重置)
- URG(urgent紧急)
- Sequence number(顺序号码)
- Acknowledge number(确认号码)

**需要注意的一点：SYN或FIN标志位的包并不携带有效数据**

**序列号为当前端成功发送的数据位数，确认号为当前端成功接收的数据位数，SYN标志位和FIN标志位也要占1位**

详情：https://blog.csdn.net/a19881029/article/details/38091243?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

**客户端TCP状态迁移：**
CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED
**服务器TCP状态迁移：**
CLOSED->LISTEN->SYN收到->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED

**各个状态的意义如下：**

**LISTEN** - 侦听来自远方TCP端口的连接请求；

**SYN-SENT** -在发送连接请求后等待匹配的连接请求；

**SYN-RECEIVED** - 在收到和发送一个连接请求后等待对连接请求的确认；

**ESTABLISHED**- 代表一个打开的连接，数据可以传送给用户；

**FIN-WAIT-1** - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

**FIN-WAIT-2** - 从远程TCP等待连接中断请求；

**CLOSE-WAIT** - 等待从本地用户发来的连接中断请求；

**CLOSING** -等待远程TCP对连接中断的确认；

**LAST-ACK** - 等待原来发向远程TCP的连接中断请求的确认；

**TIME-WAIT** -等待足够的时间以确保远程TCP接收到连接中断请求的确认；

**CLOSED** - 没有任何连接状态；

### TCP首部的信息

详情：https://blog.csdn.net/q1007729991/article/details/69261780

![1582424123872](F:\typoraImg\1582424123872.png)

### 滑动窗口      

之前传统的数据包传输是一个一个发送，当发送出去的包得到接收端的成功接收ACK回复的时候，才会发送下一个包，这种方式被称为send-wait-send模式，这样非常消耗时间，而且如果发送的包丢失了，要等待30秒才能进行重传。

1、滑动窗口可以多次发送数据包，而不用先得到ACK应答。

2、只有当接收端的窗口中的第一个字节被确认的时候，接收端的窗口才会移动，其之后应答过的包也会随之确认，不然就算之后的字节接收到了，也是处于等待中。

3、**发送端的窗口移动取决于接收端的窗口**。发送端会根据接收端的窗口中剩余字节大小来决定发送多少数据，这样又利用**控制数据传输的流量**。

### 超时重传机制

发送端发送一个数据包后，启动一个**定时器**，当定时器到时的时候，没有接收到ACK应答，则会重新发送数据。

### 快重传和快恢复

详情：https://zhuanlan.zhihu.com/p/37379780

**快重传**：对接收方来说，收到一个失序的报文段，就立刻回送一个ACK，所谓失序的报文是指，用户没有按照顺序收到 TCP 报文段，比如接收方收到了报文 M1, M2, M4，那么 M4 就称为失序报文。

这样做的目的是可以让发送方尽**可能早的知道报文段 M3 未到达接收方**。快重传算法规定，如果**发送方一连收到 3 个重复的确认，就应当立即传送对方未收到的报文 M3**，而**不必等待 M3 的重传计时器到期**。

![](F:\typoraImg\20200224190444.png)

**快恢复：**1、在收到3个重复回应的时候，执行**乘法减小算法**。是为了预防网络发生拥塞，但不执行慢开始算法。 **当采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络超时时才使用。**

2、由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认）。因此与慢开始不同之处就是现在不执行慢开始算法（即拥塞窗口现在不设置为1）而是把拥塞窗口的值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法（“加法增大”），使**拥塞窗口缓慢地线性增大**。

![1582543115644](F:\typoraImg\1582543115644.png)

### 流量控制      

**滑动窗口**协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

### TCP的拥塞处理

- **慢开始**：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;
- **拥塞避免**：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥**塞窗口按线性规律缓慢增长**。
- **快重传**：快重传要求接收方在收到一个 **失序的报文段** 后就立即发出 **重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，**发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期**。
- **快恢复：**快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就**执行“乘法减小”算法，把ssthresh门限减半**，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

​    TCP可靠性保证的机制      

- **数据包校验**：校验数据传输中有没有变化或出错，校验不通过则不响应，客户端超时后会重新发送数据
- **丢弃重复数据**
- **应答机制**：收到另一个tcp连接的时候，会返回ACK应答
- **超时重发**
- **流量控制**

### TCP与UDP的区别      

TCP是面向连接的，UDP是无连接的

TCP是可靠的，UDP是不可靠的

TCP只支持点对点通信，UDP支持一对一，一对多，多对一的通信模式

TCP是面向字节流的，UDP是面向报文的

TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；

TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

### Post与get区别      

**功能**上：post请求主要用来更新数据，get请求通常用来获取数据

**请求参数**上：post请求将请求的数据放在HTTP请求报文的 请求体 中，而get请求携带的请求数据大小有限制10k左右（根据浏览器不同）

**安全性上**：post请求比较安全，则被包装到请求体中，相对更安全，get请求都是明文出现在url后面加上参数的形式

**大小上：**get请求的请求参数的大小受限于不同浏览器上的url长度限制，post请求是没有大小限制的。

### http与https（超文本传输协议）

详情：https://www.runoob.com/w3cnote/http-vs-https.html

http和https主要是**安全性**的差别。相比于http，https（Hypertext Transfer Protocol Secure）用来传输一些私密的消息或者密码会比较**安全**。

**端口上**的不同：http使用的是**80**端口，https使用的是**443**端口。

http只需要建立好tcp连接即三次握手即可发送数据，而https除了三次握手，还需要生成一个传输数据使用的加密密钥。流程如下：

![](F:\typoraImg\20200223222252-1582468777908.png)

**获取的key即用于后续数据的加密和解密，只有客户端和服务端才知道。**

相当于服务端有一个锁头和一把钥匙，我把锁头给客户端，客户端锁住需要上锁的东西，然后发给服务端，服务端用钥匙打开锁头获取内容。

### 对称加密与非对称加密      

**对称加密**就是**加密和解密使用同一个密钥的方式**，这种方式存在的最大问题就是**密钥发送问题**，即如何安全地将密钥发给对方，优点是效率较高；

非对称加密就是使用一对非对称密钥，即**公钥和私钥**。公钥可以随意发布，但私钥只有自己知道。公钥加密的消息私钥才能解密，私钥加密的东西公钥才能解密。

结合两者的优势，可以采用一种方法：

发送者将对称加密的密钥通过公钥加密，接收者用私钥将密钥解密，这样双方都有了密钥，两边的通讯内容就通过对称密钥以对称加密算法来加解密。具体步骤：

例如针对C/S模型，

1. 服务端计算出一对秘钥pub/pri。将私钥保密，将公钥公开。
2. 客户端请求服务端时，拿到服务端的公钥pub。
3. 客户端通过AES计算出一个对称加密的秘钥X。 然后使用pub将X进行加密。
4. 客户端将加密后的密文发送给服务端。服务端通过pri解密获得X。
5. 然后两边的通讯内容就通过对称密钥X以对称加密算法来加解密。

### Cookie和session 的区别     

**概念上**：其实session是一种抽象的概念，他的作用是用来作为一种用户标识，或者说的保存记录用户的状态，而cookie是一个真实存在于客户端的，在发起http请求的时候，header中会带有cookie字段。

**存储上：**session没有大小限制，因为他是存储在服务器上的，存储的大小依赖于服务器的内存或者储存空间的大小。而cookie有大小限制。

**安全上：**cookie存储在客户端，有可能cookie被别人盗用了之后进行伪装登录等操作。所以存储在服务器上的session比较安全。

**他们的联系：**session常用于跟踪会话，用户第一次登录后，生成一个sessionid，并设置一个超时实时间存储起来，设置到cookie的字段上面，以便于下次客户端访问的时候携带sessionid用于服务端的确认。

在大型网站应用中。通常session是分布式存储，存放在内存中。

### http1.0 http1.1 http2.0

详情：https://blog.csdn.net/qq_36183935/article/details/81156225?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

![1582511663974](F:\typoraImg\1582511663974.png)

### 输入url会发生什么

详情：https://juejin.im/post/5b148a2ce51d4506965908d2#heading-5

1、DNS解析 -> IP ，查到IP后缓存在本地DNS服务器，以便下次查找（先是浏览器DNS缓存中查找，然后是操作系统的DNS缓存，读取本地HOST文件和向本地DNS服务器进行查询，如果没有查到结果，继续按照设置发起递归和迭代查询，即根域名服务器-> 顶级域名服务器 -> 域名服务器 ）

2、跟目标IP建立TCP连接（三次握手）

3、发送http请求（涉及http请求协议，请求头，请求体，重定向）

4、服务器处理请求（反向代理）

5、返回http响应（视图）（涉及http响应协议，响应头，响应正文）

6、客户端对返回的响应信息（html， js， css）解析渲染出完整页面。

7、连接结束

### http常见状态码

1xx: 请求接受成功，请求处理中

2xx: 请求成功

3xx: 重定向，要完成请求必须进行进一步处理

- 301：永久性转移
- 302：展示性转移
- 304：已缓存

4xx: 客户端错误，请求不合法

- 400：Bad Request，请求有语法问题
- 403：Forbidden，拒绝请求
- 404： 客户端访问的页面不存在

5xx: 服务端错误

- 500： Internal Server Error 服务器内部错误（web脚本错误，资源限制）
- 502：Bad Gateway web 服务器故障，进程死掉了
- 503：服务不可用（由于超载或停机维护），暂时的。
- 504：Bad Gateway timeout 网关超时

### http请求和响应报文

![](https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png)

HTTP 报文有 **请求报文** 和 **响应报文** 两种。
HTTP的这两种报文都由三部分组成：**开始行**、**首部行**、**实体主体**。

请求报文由以下内容组成：

- 请求行: 例如：`GET /logo.gif HTTP/1.1`或[状态码](https://zh.wikipedia.org/wiki/HTTP状态码)行（http版本，请求方法，URL）
- [HTTP头字段](https://zh.wikipedia.org/wiki/HTTP头字段)
- 可选的HTTP报文主体数据

响应报文：

- 响应行：例如：`HTTP/1.1 200 OK`（http版本，状态码）
- 首部
- 主体数据

示例：

```http
HTTP/1.1 200 OK  //开始行

Date: Sun, 10 Oct 2010 23:26:07 GMT	//首部行
Server: Apache/2.2.8 (Ubuntu) mod_ssl/2.2.8 OpenSSL/0.9.8g
Last-Modified: Sun, 26 Sep 2010 22:04:35 GMT
ETag: "45b6-834-49130cc1182c0"
Accept-Ranges: bytes
Content-Length: 13
Connection: close
Content-Type: text/html

Hello world!		// 主体数据
```

