# Linux总结

## linux内核组件

![1583838424941](F:\typoraImg\1583838424941.png)

## **linux调度器**

Linux 调度器将进程分为三类：

**交互式进程**：有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。

**批处理进程**：在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。

**实时进程**：实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。

​		根据进程的不同分类 Linux 采用不同的调度策略。对于**实时进程**，采用 **FIFO** 或者 **Round Robin** 的调度策略。对于**普通进程**，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 **CFS** 和 **RSDL** 等新的调度器的核心思想是“**完全公平**”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。

## **linux进程调度算法**

详情查看：https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/

**楼梯调度算法 staircase scheduler**

​		楼梯算法(**SD**)在思路上和O(1)算法有很大不同，它抛弃了动态优先级的概念。而采用了一种**完全公平**的思路。

​		和O(1)算法一样，楼梯算法也同样为每一个优先级维护一个进程列表，并将这些列表组织在active数组中。当选取下一个被调度进程时，SD算法也同样从active数组中直接读取。

**楼梯算法的优点**

​		从实现角度看，SD基本上还是沿用了O(1)的整体框架，只是删除了O(1)调度器中动态修改优先级的复杂代码；还淘汰了expire数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。

**RSDL（The Rotating Staircase Deadline Schedule）**

​		是对SD算法的改进。核心的思想还是“完全公平”。没有复杂的动态优先级调整策略。

​		在SD算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得CPU。因此低优先级进程的等待时间无法确定。RSDL中，当高优先级进程组用完了它们的Tg(即组时间配额)时，无论该组中是否还有进程Tp尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是RSDL中Deadline代表的含义。

​		和SD同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为minor rotation而降到了低优先级进程队列中。当它重新进入RUNNING状态时，就获得了相对较高的优先级，从而能被迅速响应。

**CFS 完全公平调度器（Completely Fair Scheduler）**

​		CFS是最终被内核采纳的调度器。它从RSDL/SD中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。

​		CFS调度器用红黑树代替优先级数组；用完全公平的策略代替动态优先级策略；引入了模块管理器；相比于RSDL，虽然都基于完全公平的原理，但是它们的实现完全不同。相比之下，CFS更加清晰简单，有更好的扩展性。CFS还有一个重要特点，即**调度粒度小**。CFS之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，**每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占**。而CFS则在每次tick都进行检查，如果**当前进程不再处于红黑树的左边，就被抢占**。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。

## fork

​		通常是[内核](https://zh.wikipedia.org/wiki/内核)实现的一种[系统调用](https://zh.wikipedia.org/wiki/系统调用)。Fork是类Unix操作系统上创建进程的一种主要方法，甚至历史上是唯一方法。

​		在多任务操作系统中，[行程](https://zh.wikipedia.org/wiki/行程)（运行的程序）需要一种方法来创建新进程，例如运行其他程序。如果进程需要启动另一个程序的可执行文件，它需要先Fork来创建一个自身的副本。然后由该副本即“[子进程](https://zh.wikipedia.org/wiki/子进程)”调用[exec](https://zh.wikipedia.org/w/index.php?title=Exec&action=edit&redlink=1)系统调用，用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。

**Fork操作会为子进程创建一个单独的[地址空间](https://zh.wikipedia.org/wiki/定址空間)。子进程拥有父进程所有内存段的精确副本**。

![1583839897467](F:\typoraImg\1583839897467.png)



## 进程间的通讯方式 IPC 

IPC (InterProcess Communication)

**匿名管道**( pipe )：管道是一种**半双工**的通信方式，数据只能**单向流动**，而且**只能在具有亲缘关系的进程间使用**。进程的亲缘关系通常是指`父子进程关系或者兄弟进程`。相对于有名管道而言，无名管道在使用时产生，不使用后释放，并不会在系统上留下蛛丝马迹。就因为它在使用前没有任何的标识，所以也**只能适用于父子进程或者具有血缘关系的进程间通讯**
    **有名管道** (named pipe)：有名管道也是**半双工**的通信方式，但是它**允许无亲缘关系进程间的通信有名管道在文件目录中有一个文件标示（管道文件）**。实际不占据磁盘空间。数据缓存在内存上（只有使用时内存才开辟，由于在内存上，因此管道文件的属性中所占空间大小为0字节；当两个进程间一读一写完成后，管道文件也立即在内存清空）。
    **信号量**( semophore )：信号量是一个`计数器`，可以用来**控制多个进程对共享资源的访问**。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    **消息队列**( message queue )：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。而且对发送的数据块有选择性的接收数据。
    **信号** ( sinal )：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
    **共享内存**( shared memory )：共享内存就是映射一段能被其他进程所访问的内存，这段**共享内存由一个进程创建，但多个进程都可以访问**。共享内存是**最快的IPC方式**，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通。
    **套接字**( socket )：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

## 内核态与用户态

![](https://segmentfault.com/img/remote/1460000011899643)

- 内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。

- 用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。

系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。