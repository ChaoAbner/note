# 孤儿进程和僵尸进程

## 孤儿进程

**父进程退出**，它的子进程就会成为孤儿进程，所有的孤儿进程都会**被init进程接管**，**释放它们占用的系统资源**。孤儿进程没有实质性危害。

## 僵尸进程

进程通过fork创建子进程，如果子进程退出，父进程没有调用`wait`、`waitpid`等系统函数获取子进程的状态，那么**子进程的描述符、进程号就会一直被占用**，成为僵尸进程。
 很明显，僵尸进程会占用系统资源，过多的僵尸进程会导致进程号耗尽，无法创建新进程。

> 相关机制:子进程退出后，系统会回收文件、内存等资源，但不会回收进程号，它要等到父进程调用`wait`后才会被释放。

预防出现僵尸进程的方法：
1. 等； 2. 不等； 3. 是孤儿而非僵尸

**预防办法一**

在fork()/execve()过程中，在父进程**fork()之前安装SIGCHLD信号处理函数**，并在此handler函数中调用waitpid()等待子进程结束，这样，**内核才能获得子进程退出信息从而释放那个进程描述符**。

**预防方法二**
设置SIGCHLD信号为SIG_IGN（即，忽略SIGHLD信号），系统将不产生僵尸进程。
比如：对于服务器进程，如果父进程不等待子进程就结束，子进程将成为僵尸进程；若父进程等待子进程结束，就会影响服务器进程的并发性能。所以此时一般就将SIGCHLD信号设置为SIG_IGN.
**预防方法三**
用两次fork()，然后使儿子进程直接退出，从而使孙子进程成为孤儿进程，进而由init进程负责清除这个孤儿进程。



## 解决方法

1、子进程退出后，发送`SIGCHILD`信号，父进程在信号处理函数中调用`wait`接受子进程的状态。

2、或者可行的话，直接杀死父进程，使子进程成为孤儿进程，由init进程接管。