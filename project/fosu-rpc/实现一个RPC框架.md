# 实现一个RPC框架

一般情况下，RPC框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的RPC框架才算真正合格的。

fosu-rpc的架构如下图：

![image-20210113151657579](http://img.fosuchao.com/687474703a2f2f696d672e666f73756368616f2e636f6d2f696d6167652d32303231303131333135313635373537392e706e67)

服务端向注册中心注册服务，客户端通过通过注册中心获取服务地址，然后在通过网络请求服务提供段Server。

再来看看一个比较完整的RPC架构图：


![image-20210220105345089](http://img.fosuchao.com/image-20210220105345089.png)

简单说下一个最基本的RPC框架的思路以及需要哪些东西

1. 注册中心
2. 网络传输
3. 序列化和反序列化
4. 动态代理
5. 负载均衡
6. 传输协议

## 注册中心

注册中心有很多选择，比如Redis、Zookeeper等等，这里推荐使用Zookeeper作为注册中心。

ZooKeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现 诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理Master选举、分布式锁和分布式队列等功能。并且ZooKeeper将数据保存在内存中，性能是非常棒的。 

在**读多写少**的应用程序中尤其地高性能，因为**写**会导致所有的服务器间同步状态。（读多于写是协调服务的典型场景）。

**注册中心负责服务地址的注册与查找，相当于目录服务**。 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。

通过Dubbo的架构来理解下

![image-20210220105846987](http://img.fosuchao.com/image-20210220105846987.png)

上述节点简单说明：

Provider：暴露服务的服务提供方 

Consumer：调用远程服务的服务消费方 

Registry：服务注册与发现的注册中心 

Monitor：统计服务的调用次数和调用时间的监控中心 

Container：服务运行容器

调用关系说明：

1. 服务容器负责启动，加载，运行服务提供者。 

2. 服务**提供者**在启动时，向注册中心**注册**自己提供的服务。

3. 服务**消费者**在启动时，向注册中心**订阅**自己所需的服务。

4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。

5. 服务消费者，从提供者地址列表中，基于**软负载均衡算法**，选一台提供者进行调用，如果调用失败，再选另一台调用。

6. 服务消费者和提供者，在内存中累计调用次数和调用时间，**定时每分钟发送一次统计数据到监控中心**。

## 网络传输

网络传输的具体实现可以用Socket，即最原始的网络编程，但是，Socket是阻塞IO，性能低并且功能单一。

你可以使用同步非阻塞IO即NIO，但是使用NIO编程很麻烦，需要有很强的代码功底。所以还是推荐使用基于NIO的Netty框架。

### 简单介绍下Netty

1. Netty是一个基础NIO的客户端服务端框架，使用他能快速开发网络应用程序
2. 极大简化了TCP和UDP套接字服务器等网络编程，并且性能以及安全性甚至更好，封装了很多NIO的实现，屏蔽了那些复杂的逻辑
3. 支持多种网络协议FTP，SMTP，HTTP以及各种二进制和编解码协议。

## 序列化和反序列化

要在网络中传输的数据就需要涉及序列化。

### 为什么需要序列化和反序列化

因为网络传输的数据必须是二进制的。因此Java对象没法直接在网络中进行传输，为了能让java对象在网络中传输，我们需要将其序列化为二进制的数据。

我们最终需要的还是目标Java对象，因此还需要把二进制数据解析为Java对象，也就是反序列化

另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。

![image-20210220114319180](http://img.fosuchao.com/image-20210220114319180.png)

### 序列化方式

JDK有自带的序列化，只需要实现`java.io.Serializable`接口即可，不过这种方式不推荐，因为**不支持跨语言并且性能较差**。

推荐的序列化方式有**hessian、kyro、protostuff** 等

## 动态代理

我们知道的代理模式就是：给某一个对象提供一个代理对象，并由代理对象代替真实对象做一些事情。

举个例子：在调用真实对象的方法的时候，我们可以通过代理对象去做一些安全校验，日志打印等操作，这个过程对于真实对象是屏蔽的。

### 动态代理在RPC框架中的作用

RPC的主要目的就是让我们调用远程方法像调用本地方法 一样简单，我们不需要关心远程方法调用的细节比如网络传输。

**怎么屏蔽方法调用的底层细节呢**

答案就是使用**动态代理**，简单来说，当调用远程方法的时候，实际会通过代理对象来发送网络请求。

## 负载均衡

负载均衡也是需要的。我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上， 当客户端发起请求的时候，多台服务器都可以处理这个请求。那么如何正确选择处理该请求的 服务器就很关键。假如你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。

fosu-rpc中实现了随机算法和一致性哈希算法。

常见的负载均衡算法有：

1. 轮询（Round Robin）法
2. 随机法
3. 源地址哈希法 
4. 加权轮询（Weight Round Robin）法
5. 加权随机（Weight Random）法
6. 一致性哈希算法

## 传输协议

我们还需要涉及一个RPC传输协议，这个协议是客户端和服务端通信的基础。

### 协议的作用

通过设计协议，我们定义需要**传输哪些类型的数据**，并且还会规定**每一种类型的数据应该占用多少字节**，这样我们在接受到二进制数据后，就可以正确的解析出我们需要的数据。这有点像密文传输的感觉。

标准RPC协议一般包括一下内容：

1. **魔数** ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。（类似于Java字节码中的CAFE） 

2. **序列化器编号** ：标识序列化的方式，比如是使用Java自带的序列化，还是json，kyro等序列化方式。 

3. **消息体长度** ： 运行时计算出来。
4. ...

fosu-rpc的RPC协议设计如下图：

![image-20210220115820061](http://img.fosuchao.com/image-20210220115820061.png)

## 实现一个RPC框架需要哪些技术

### Java

动态代理机制； 

序列化机制以及各种序列化框架的对比，比如 hession2、kyro、protostuff； 

线程池的使用； 

CompletableFuture 的使用； 

### Netty

使用 Netty 进行网络传输； 

ByteBuf 介绍； 

Netty 粘包拆包； 

Netty 长连接和心跳机制； 

### Zookeeper

基本概念； 

数据结构； 

如何使用 Netflix 公司开源的 zookeeper 客户端框架 Curator 进行增删改查； 