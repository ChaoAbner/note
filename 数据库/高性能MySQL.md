## MySQL架构与历史

### MySQL逻辑架构

![1573630121897](F:\typoraImg\1573630121897.png)

### 并发控制

​		主要在服务器层与存储引擎层来讨论。

#### 读写锁

​		用户在并发读取数据的时候不会发生什么问题，但是当一个用户读取数据的时候，另一个用户删除了该数据，那么可能发生生不确定的后果。

![1573630236007](F:\typoraImg\1573630236007.png)

#### 锁粒度

![1573630342932](F:\typoraImg\1573630342932.png)

​		加锁也需要消耗资源。锁的各种操作，都会增加系统的开销。我们需要了解一些重要的锁策略。

##### 表锁（table lock）

![1573630441778](F:\typoraImg\1573630441778.png)

##### 行级锁（row lock）

![1573630479193](F:\typoraImg\1573630479193.png)

### 事务

​		事务的**ACID**概念：**原子性（atomicity），一致性（consistency），隔离性（isolation），持久性（durability）**

![1573630599393](F:\typoraImg\1573630599393.png)

#### 隔离级别

​		隔离级别有4个： **未提交读（read uncommited），提交读（read commited），可重复读（repeatable read），可串行化（serializable)**

![1573630715627](F:\typoraImg\1573630715627.png)

#### MySQL中的事务

​		MySQL提供了两种事务性的存储引擎：**InnoDB和NDB Cluster**。

##### 自动提交（autocommit）

![1573630832753](F:\typoraImg\1573630832753.png)

##### 设置隔离级别

![1573630893802](F:\typoraImg\1573630893802.png)

### 多版本并发控制（MVCC）

![1573631010472](F:\typoraImg\1573631010472.png)

​		`MVCC`可以理解为行级锁的变种，很多情况下避免了加锁操作，降低了开销，实现了非阻塞的读操作，写操作时只锁定必要的行。

​		`MVCC`实现的不同的，典型的有**乐观并发控制和悲观并发控制。**

​		`InnoDB`的`MVCC`通过每行记录后面保存两个隐藏的列来实现。一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。**存储的是时间值实际是系统版本号**（system version number）。**每开始一个事务，系统版本号都会自动递增。**![1573631467728](F:\typoraImg\1573631467728.png)	

![1573631399734](F:\typoraImg\1573631399734.png)

​		

### MySQL的存储引擎

#### 查看表的信息

![1573631645913](F:\typoraImg\1573631645913.png)

​		其中**engine**中的信息代表存储引擎的类型。

​		**MySQL的默认存储引擎是InnoDB**。我们在选择存储引擎的时候需要考虑多个因素：

- 事务
- 备份
- 崩溃恢复
- 特有的特性（如MyISAM支持地理空间搜索）

#### 切换表的存储引擎

![1573632150281](F:\typoraImg\1573632150281.png)

## MySQL基准测试

### 为什么需要基准测试

​		基准测试时唯一方便有效的测试系统在给定的工作负载或者不同压力下会发生什么情况。

![1573632617131](F:\typoraImg\1573632617131.png)

![1573632627650](F:\typoraImg\1573632627650.png)

### 基准测试的策略

​		有两个策略：**针对整个系统的整体测试；单独测试MySQL。也成为集成式以及单组件式。**

#### 测试指标

- **吞吐量** - 单位时间内的事务处理数
- **响应时间或延迟** - 测试任务所需的整体时间
- **并发性** - 任意时间有多少同时发生的并发请求

![1573633958838](F:\typoraImg\1573633958838.png)

![1573633868095](F:\typoraImg\1573633868095.png)

- **可拓展性** - 系统的性能还可承受多少压力

### 基准测试方法

### 基准测试工具

#### 集成式测试工具

- ab
- http_load
- JMeter

#### 单组件式测试工具

- mysqlslap
- sql-bench
- super smack
- database test suite

![1573634541213](F:\typoraImg\1573634541213.png)

## 服务器性能剖析

## Schema（架构）与数据类型优化

### 选择优化的数据类型

​		选择正确的数据类型对于获得高性能来说很重要，通常来说选择应该遵循以下原则：

- 更小的通常更好（比如只需要存0-200 则使用tinyint unsigned 更好）

  ![1574232855609](F:\typoraImg\1574232855609.png)

- 简单就好

![1574232982204](F:\typoraImg\1574232982204.png)

- 尽量避免NULL

![1574233096665](F:\typoraImg\1574233096665.png)

#### 整数类型

![1574233439101](F:\typoraImg\1574233439101.png)

#### 字符串类型

**分为varchar和char类型**

- varchar（存储可变长字符串）

![1574233633803](F:\typoraImg\1574233633803.png)

![1574233739690](F:\typoraImg\1574233739690.png)

- char（存储定长字符串）

![1574233818183](F:\typoraImg\1574233818183.png)

##### BLOB和TEXT类型

![1574233995372](F:\typoraImg\1574233995372.png)

#### 日期和时间类型

![1574234504443](F:\typoraImg\1574234504443.png)

两种相似的日期类型：datetime和timestamp

#### 位数据类型

BIT

#### 特殊类型数据

![1574234745540](F:\typoraImg\1574234745540.png)

### 加快ALTER TABLE操作的速度

#### 快速创建MyISAM索引

![1574237471164](F:\typoraImg\1574237471164.png)

## 创建高性能的索引

​		**索引是存储引擎快速找到记录的一种数据结构**。数据量小的时候，索引的作用可能不大，当时当数据量大起来的时候，索引的重要性就愈发重要。

### 索引基础

#### 索引类型

- B-Tree索引

![1574387893713](F:\typoraImg\1574387893713.png)

B-Tree的表示

![1574393891039](F:\typoraImg\1574393891039.png)

- 哈希索引

![1574407312014](F:\typoraImg\1574407312014.png)

加入有以下数据

![1574407414051](F:\typoraImg\1574407414051.png)

有一个哈希函数f(x)，他返回下面的哈希值

![1574407447797](F:\typoraImg\1574407447797.png)

则哈希索引的数据结构如下：

![1574407465670](F:\typoraImg\1574407465670.png)

假如要查询一个数据

`mysq> select lname from testhash where fname = 'Peter';`

![1574407562836](F:\typoraImg\1574407562836.png)

**哈希索引的限制：**

![1574407661544](F:\typoraImg\1574407661544.png)

![1574407671012](F:\typoraImg\1574407671012.png)

- 空间数据索引（R-Tree）

![1574585145543](F:\typoraImg\1574585145543.png)

- 全文索引

![1574585162306](F:\typoraImg\1574585162306.png)

### 索引的优点

总结下来有三个优点：

### ![1574585197522](F:\typoraImg\1574585197522.png)高性能的索引策略🔺

#### 独立的列

![1574585649795](F:\typoraImg\1574585649795.png)

#### 前缀索引和索引选择性

​		索引很长的字符串，可以使用哈希索引，不过还不够，还可以使用前缀索引。之索引开始的部分字符，这样可以大大节约索引的空间。从而提高效率。

**步骤**：

- 先找到合适的前缀长度
- 创建前缀索引

**缺点**：

![1574586375203](F:\typoraImg\1574586375203.png)

### 多列索引

![1574596833025](F:\typoraImg\1574596833025.png)

### 选择合适的索引列顺序

![1574596948004](F:\typoraImg\1574596948004.png)

可以先衡量customer_id和staff_id的数据数量，将数据少的索引放前面。

### 聚簇索引🔺

P00

### 总结

​		MySQL大多数情况下使用B-Tree索引。

​		在选择索引和编写利用这些索引查询时，有三个原则：

![1574693773097](F:\typoraImg\1574693773097.png)

## 查询性能优化

### 慢查询基础：优化数据访问

MySQL能够使用如下三种方式应用where条件，从好到坏一次为：

![1575029172115](F:\typoraImg\1575029172115.png)

​		好的索引对于数据的访问来说很重要，可以减少扫描的行数。**尽量让扫描的行数和实际返回的行数在数量上接近。**

​		如果扫描很多行，但是却返回很少行的话，我们可以采用以下的优化。

![1575029417174](F:\typoraImg\1575029417174.png)

### 重构查询方式

#### 复杂查询还是多个检查查询

![1575030019623](F:\typoraImg\1575030019623.png)

#### 切分查询（分而治之）

![1575030100480](F:\typoraImg\1575030100480.png)

将一个删除操作分次进行，可以将服务器一次性的压力分散到一个很长的时间段。可以大大减少删除时锁的持有时间。

#### 分解关联查询

![1575030948156](F:\typoraImg\1575030948156.png)

优势如下：

- 第一次查询的tag=‘mysql’已经缓存，下面的查询就不用再去查询tag了。
- 拆分可以降低锁的竞争

![1575031079330](F:\typoraImg\1575031079330.png)

### 查询的执行

​		MySQL的查询过程

![1575031288484](F:\typoraImg\1575031288484.png)

1. 先查询缓存，如果之前查过则直接返回。
2. 通过解析器解析SQL，进行预处理，还有优化器生成对应的执行计划。
3. 根据执行计划调用查询引擎的API来执行查询。
4. 返回结果。

### MySQL客户端/服务端的通信协议

​		客户端与服务端的通信协议是**半双工**的，意味着：

![1575031461407](F:\typoraImg\1575031461407.png)

#### 查询优化处理

下面是MySQL能够处理的优化类型：

- 重新定义关联表的顺序
- 将外连接转化成内连接

![1575033202103](F:\typoraImg\1575033202103.png)

- 使用等价变换规则

![1575033299562](F:\typoraImg\1575033299562.png)

- 优化count(), min(), max()
- 预估并转化为常数表达式
- 覆盖索引扫描
- 子查询优化
- 提前终止查询

