# Redis总结

**1、redis和memcached的区别，为什么单线程的redis有时比memcached的效率高**

​		1、memcached可以存储图片或者视频，redis支持key/value的很多数据结构

​		2、redis可以使用虚拟内存。可以通过RDB和AOF进行持久化和灾难恢复。redis支持主从备份。

​		3、redis可以做消息队列。

​		原因：**memcached**多线程模型引入了**缓存一致性**和**锁**，**加锁带来了性能损耗**。

**2、redis 主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？**![1582196748156](F:\typoraImg\1582196748156.png)

​		寻址：http://blog.itpub.net/69917606/viewspace-2642545/

**3、使用redis实现分布式锁？实现思路？使用zk可以吗？怎么实现？这两种有什么区别？**

​		可以使用redis的setnx()方法

​		1、线程A setnx()，设置超时时间t1，如果返回true，则获得锁

​		2、线程B用get获取t1，判断是否超时。如果超时了，则执行第三步、没超时返回false。

​		3、计算新的超时时间t2，使用getset()返回t3，如果t3==t1的话，则获得锁（CAS原理）。否则，说明锁被其它线程获取了。

​		4、获取锁后，处理完业务逻辑，**先判断锁是否超时**，如果没超时则删除锁，如果超时，不用处理。（防止删除其它线程获得的锁）。

**4、redis的持久化？底层是怎么实现的？有什么优缺点？**

​		RDB(redis database)：在不同时间点将redis的**数据生成的快照同步到磁盘**等介质，定期更新。缺点：耗时，性能低（I/O），易丢失数据。（数据同步到磁盘）

​		AOF(append only file): 将redis执行过的所有指令记录下来（记录执行指令）。下次重启时，只需要重新执行所有的指令。缺点：体积大，恢复速度慢。

**5、redis过期策略有哪些？LRU算法的实现？**

​		1、定时过期（定时清理过期的key）

​		2、惰性过期（当用到key的时候才判断是否过期和是否清理）

​		3、LRU算法（保证不常用的数据在队列的后面）原理FIFO

​			LRU实现：使用双向链表LinkedHashMap实现。（HashMap是无序的，LinkedHashMap维护了迭代顺序。）

​			1、新的数据插到链表头部

​			2、缓存命中的时候，将数据移到链表头

​			3、链表满的时候，将链表后面的数据丢弃。			

**6、缓存穿透、缓存击穿、缓存雪崩的解决方案？**

​		缓存穿透：指定不存在的数据，存储层查不到数据则不写入缓存。导致这个不存在的数据每次请求都到DB去查询。可能导致DB挂掉。

​		解决方案：1、将这个key缓存起来，设置较短的过期时间 2、一个Map来保存这些key，作为一个过滤器。如果有key，则不请求DB。

------

​		缓存击穿：一个设置了过期时间的key在某个时间点过期，刚好那时有大量请求该数据。导致全部请求到达DB，导致DB挂掉。

​		解决方案：1、使用互斥锁，setnx()。当一个缓存失效时，请求先不请求DB，先加个互斥锁，其他线程等待。然后再请求DB数据缓存起来，释放锁后其它线程即可直接访问缓存了。2、永不过期

------

​		缓存雪崩：设置了很多**相同过期时间**的热点数据，当过期时大量请求直接请求数据库，导致DB挂掉。

​		解决方案：

​			**事前：**1、在设置过期时间的时候可以设置加上一个随机值，防止大量key同时失效。2、搭建redis集群。

​			**事后：**1、通过加锁或者入队列的方式对请求数据库和写缓存的线程进行限制。只允许一个线程查询数据和写入缓存。释放锁后其它线程即可查询新写入缓存的数据了。

**7、选择缓存的时候，什么时候选redis，什么时候选择memcached？**

​		选**redis**：1、需要复杂的数据结构。2、需要数据持久化的功能。3、高可用场景，redis支持集群。可实现主动复制，读写分离。对于memcached要实现高可用，需进行二次开发。4、存储内容比较大，memcached存储的value最大为1M。

​		选**memcached**：1、纯K/V，数据量很大的业务。

![1582201193241](F:\typoraImg\1582201193241.png)

2、网络模型，memcached是非阻塞的IO复用模型。

3、线程模型，memcached使用多线程，主线程监听，worker子线程接收请求，执行读写。充分利用多核性能提升吞吐量。

**8、缓存与数据库不一致怎么办？**

![1582201379625](F:\typoraImg\1582201379625.png)

**9、主从数据库不一致怎么办？**![1582201558749](F:\typoraImg\1582201558749.png)

**10、redis常见的性能问题和解决方案**![1582201614010](F:\typoraImg\1582201614010.png)

**11、redis的数据淘汰策略有哪些？**

​		**voltile-lru** 从设置过期时间的数据集中挑选**最近最少使用**的数据淘汰。

​		**voltile-ttl** 从设置了过期时间的数据集中挑选**将要过期**的数据。

​		**voltile-random** 从设置了过期时间的数据集中**任意随机**选择淘汰数据。

​		**allkeys-lru** 从数据集中挑选最近最少使用的数据淘汰。

   	**allkeys-random** 从数据集中任意随机体挑选数据淘汰。

​		**no-eviction** 禁止驱逐数据。

**13、redis中有一亿个key，其中有10w个key是以固定的已知前缀开头，如何找出来？**

​		使用**keys+通配符**的方法列出所有一直前缀的key ，比如前缀是like `keys like* `

​		使用keys的问题：因为redis是单线程的，key数据量太大的话会阻塞一段时间才可进行其它业务

​		更好的方式：使用**scan**指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会**有一定的重复概率**，需要去重。整体花费的时间比keys指令长。`scan 0 match *like`

**14、redis怎么做异步队列，怎么实现？**

​		使用list保存数据，rpush生产消息，lpop消费消息。当lpop没有消息时，可以sleep一段时间，再去检查。如果不用sleep的话，可以使用blpop，再没有消息的时候，会一直阻塞。知道消息到来。

​		为什么blpop会阻塞？redis不是单线程的吗？其它命令还能执行吗

![1582203192441](F:\typoraImg\1582203192441.png)

**15、redis如何实现延时队列？**

​		使用**sortedset**，使用时间戳作为score，消息内容作为key，调用zadd来生产消息。消费者使用**zrangebyscore**获取n秒前的数据做轮询处理。

**16、什么是redis？他的优缺点？**

​		key/value类型的内存数据库，缓存数据库。定期通过异步操作将数据flush到硬盘上保存。数据类型很多，可以利用这个特点做很多服务（消息队列，延时队列）。

​		缺点：因内存的限制，不能用作海量数据的高性能读写。主要用于叫小数据量的高性能操作和运算上。

**17、redis相比memcached的优势**![1582203771944](F:\typoraImg\1582203771944.png)

**18、redis的集群方案应该怎么做？有哪些方案？**

Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。

Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。

**Redis Cluster 节点分配**

参考：https://www.jianshu.com/p/26e61d1161af

```
// 在redis安装目录常见cluster文件夹，在创建端口对应文件夹和配置文件
// 安装命令
redis-server --service-install cluster/7100/redis.7100.conf --service-name redis7100
// 卸载命令
redis-server --service-uninstall --service-name redis7100
// 启动命令
redis-server --service-start --service-name redis7100
// 停止命令
redis-server --service-stop --service-name redis7100
```

Redis Cluster 特点：

1. 所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。
2. 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
3. 客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。
4. redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。
5. Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。

**Redis Cluster 主从模式**

Redis Cluster 为了保证数据的高可用性，加入了主从模式。

一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。

------

**Redis Sentinel**

Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：

- **监控（Monitoring）**  - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
- **提醒（Notification）**  - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
- **自动故障迁移（Automatic failover）**  - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。

Redis 集群中应该有奇数个节点，所以至少有三个节点。

哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。

假设集群仅仅部署 2 个节点

```
+----+         +----+| M1 |---------| R1 || S1 |         | S2 |+----+         +----+
```

如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。

**redis-cluster通信协议**

redis cluster节点间采取`gossip`协议进行通信

gossip协议包含多种消息，包括`ping，pong，meet，fail`等等。

- meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；

- ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据；

- pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新；
- fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。