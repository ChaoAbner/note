# 数据结构与对象

## 跳跃表

​		跳跃表是一种**有序数据结构**，通过每个节点中维持多个指向其它节点的指针，从而实现快速访问节点的目的。

​		Redis使用跳跃表作为有序集合键的底层实现之一，如果一个**有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时**，Redis就会使用跳跃表来作为有序集合键的底层实现。

### 跳跃表实现

​		跳跃表由`zskiplistNode`和`zskiplist`两个结构定义，其中`zskiplistNode`标识跳跃表节点，`zskiplist`用于保存跳跃表节点的相关信息，比如**节点数量，指向表头的指针和表尾节点的指针等**。

![1572239006090](F:\typoraImg\1572239006090.png)

  	上图最左边的是`zskiplist`结构，包括一下属性

- header：指向跳跃表的**表头节点**。
- tail：指向跳跃表的**表尾节点**。
- level：记录目前跳跃表内，**层数最大的那个节点的层数**。
- length：记录跳跃表的长度，也就是**跳跃表目前包含节点的数量**。



​	位于`zskiplist`右边的结构是`zskiplistNode`，包括以下属性

- 层（level）节点中的L1，L2等，每个层都有两个属性：**前进指针和跨度**。前进指针用于访问位于表尾方向的其他节点，跨度则记录了前进指针所指向节点和当前节点的距离。（图中带数字的箭头就代表跨度，指向就代表前进指针）
- 后退（backward）节点中用`BW`标记节点的后退指针，指向位于当前节点的前一个节点。**表尾向表头遍历时使用**。
- 分值（score）1.0，2.0等，按**从小到大排序**
- 成员对象（obj）o1，o2等

### 跳跃表节点

![1572239724191](F:\typoraImg\1572239724191.png)

### 跳跃表重点

- 跳跃表是**有序集合**的底层实现之一。
- Redis的跳跃表实现由`zskiplist`和`azskiplistNode`两个结构组成，其中`zskiplist`用于保存跳跃表信息（比如表头节点、表尾节点、长度），而`zskiplistNode`用于表示跳跃表节点。
- 每个跳跃表节点的层高都是**1到32之间的随机数**。
- 同一跳跃表中，多个节点可以包含相同的分值，但**每个节点的成员对象必须是唯一的**。
- 跳跃表中的节点按照分值大小排序，当分值相同时，节点按照成员对象的大小进行排序。

## 整数集合

​		整数集合（intset）时集合键的底层实现之一，**当一个集合只包含整数值元素，并且这个集合的元素数量不多**时，Redis就会使用证书集合作为集合键的底层实现。

### 整数集合实现

![1572241241650](F:\typoraImg\1572241241650.png)

​		`contents`数组的元素按从小到大有序排列，并且元素不重复。

### 升级

​		为整数集合添加元素时，需要先进行升级（upgrade），升级集合并且添加新元素分为三步进行：

- 根据新元素的类型，扩展集合空间，为新元素分配空间。
- 将底层数组的所有元素类型都转换成新元素的类形，并将类型转换后的元素放到正确的位置上，并保持有序性不变。
- 将新元素添加到底层数组里面。

![1572265936572](F:\typoraImg\1572265936572.png)

​		升级的好处：提升整数集合的灵活性；尽可能地节约内存。

​		整数集合不能降级，就算比较大的元素删除，也不能降级。

### 整数集合重点

- 整数集合是集合键的底层实现之一
- 整数集合底层实现是数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，会根据新元素的类型来改变数组的类型
- 升级提升了整数集合的灵活性；尽可能地节约内存，**不支持降级**



## 压缩列表

​		压缩列表（ziplist）是**列表键和哈希键**的底层实现之一。当一个**列表键只包含少量列表项**，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

![1572313854406](F:\typoraImg\1572313854406.png)

![1572313861381](F:\typoraImg\1572313861381.png)

### 压缩列表的构成

​		压缩列表是Redis为节约内存开发的。一个压缩列表包含任意多个节点（entry），**每个节点可以保存一个字节数组或者一个整数值**。

​		压缩列表的组成部分如下图：

![1572314108323](F:\typoraImg\1572314108323.png)

![1572314016646](F:\typoraImg\1572314016646.png)

​		压缩列表示例

![1572314179766](F:\typoraImg\1572314179766.png)

### 压缩列表的节点构成

​		每个压缩列表的节点可以保存一个字节数组或者一个整数值，每个Entry的构成如下图

![1572314328531](F:\typoraImg\1572314328531.png)

- previous_entry_length: 记录了压缩列表中前一个节点的长度。（该属性的长度可以是1-5个字节）

  - 如果前一个节点的长度**小于**254字节，那么previous_entry_length属性要用**1字节**长的空间来保存这个长度值
  - 如果前一个节点的长度**大于等于**254字节，那么previous_entry_length属性要用**5字节**长的空间来保存这个长度值

  ![1572314620905](F:\typoraImg\1572314620905.png)

  **因为当前节点记录了前一个节点的长度，所以可以根据当前节点的起始地址来计算出前一个节点的起始地址。**

  压缩列表从表尾向表头的遍历操作就是使用这一原理实现的。

  ![1572314915429](F:\typoraImg\1572314915429.png)

- encoding：记录了节点的content属性所保存数据的类型以及长度

- content：保存节点的值

### 连锁更新

![1572315284196](F:\typoraImg\1572315284196.png)

​		e1的`previous_entry_length`只有一个字节，为了让e1能记录新节点的长度，则需要对e1进行扩展，让`previous_entry_length`扩展至5个字节。

​		从而e1的扩展也引发了e2，以及后续节点的扩展。

### 重点

- 压缩列表是一种为节约内存而开发的顺序性数据结构
- 压缩列表被用作列表键和哈希键的底层实现之一。
- 压缩列表可以包含多个节点， 每个节点可以保存一个字节数组或者一个整数值。
- 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新。

## 对象

​		Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等。

​		Redis没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，包含：**字符串对象、列表对象、哈希对象、集合对象和有序集合对象**，每个对象都用到了至少一种上面的数据结构。

### 对象的类型与编码

​		Redis在数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键，一个对象用作值。

![1572316295839](F:\typoraImg\1572316295839.png)

#### 类型

![1572316423487](F:\typoraImg\1572316423487.png)

![1572316451258](F:\typoraImg\1572316451258.png)

#### 编码和底层实现

​		对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。

​		encoding属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现。属性值对应下面代表中的常量

![1572316739222](F:\typoraImg\1572316739222.png)

​		每种类型的对象都至少使用了两种不同的编码，下表列出每种类型的对象可以使用的编码。

![1572316871040](F:\typoraImg\1572316871040.png)

​		使用`OBJECT ENCODING`命令可以查看一个数据库键的值对象的编码

![1572316977765](F:\typoraImg\1572316977765.png)

![1572316989578](F:\typoraImg\1572316989578.png)

​		Redis可以根据不同场景来为一个对象设置不同的编码，从而优化对象在某场景下的效率：

![1572317091580](F:\typoraImg\1572317091580.png)

### 字符串对象

​		字符串对象的编码可以是**int、raw或者embstr**；

![1572317169117](F:\typoraImg\1572317169117.png)

![1572317238650](F:\typoraImg\1572317238650.png)

​		执行命令

![1572317273146](F:\typoraImg\1572317273146.png)

![1572317288676](F:\typoraImg\1572317288676.png)

![1572317364854](F:\typoraImg\1572317364854.png)

![1572317372803](F:\typoraImg\1572317372803.png)

​		**embstr编码的字符串对象来保存短字符串值的好处**

![1572317461821](F:\typoraImg\1572317461821.png)

​		执行命令

![1572317506161](F:\typoraImg\1572317506161.png)

![1572317512370](F:\typoraImg\1572317512370.png)

### 列表对象

![1572359001363](F:\typoraImg\1572359001363.png)

若对象使用的是`ziplist`编码，那么这个键的值对象如下图：

![1572359046917](F:\typoraImg\1572359046917.png)

`linkedlist`编码的列表对象使用了双端链表作为底层实现。每个双端链表节点（node）都保存了一个字符串对像，而每个字符串对象都保存了一个列表元素。

键的值对象如下图：

![1572359411376](F:\typoraImg\1572359411376.png)

#### 编码转换

列表对象使用`ziplist`编码的两个条件：

- 列表对象保存的**所有字符串元素的长度都小于64字节**；
- 列表对象保存的**元素数量小于512个**；不满足这两个条件的列表对象则使用`linkedlist`编码；

### 哈希对象

![1572402719567](F:\typoraImg\1572402719567.png)

![1572402728122](F:\typoraImg\1572402728122.png)

执行命令

![1572402912269](F:\typoraImg\1572402912269.png)

​		`hashtable`编码的哈希对象使用**字典**作为底层实现，哈希对象中的**每个键值对都使用一个字典键值对来保存**：

- 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
- 字典的每个值都是一个字符串对象，对象中保存了键值对的值；

![1572403032532](F:\typoraImg\1572403032532.png)

#### 编码转换

列表对象使用`ziplist`编码的两个条件：

- 列表对象保存的**所有字符串元素的长度都小于64字节**；
- 列表对象保存的**元素数量小于512个**；不满足这两个条件的哈希对象则使用`hashtable`编码；

### 集合对象

![1572403155250](F:\typoraImg\1572403155250.png)

![1572403180263](F:\typoraImg\1572403180263.png)

![1572403190660](F:\typoraImg\1572403190660.png)

#### 编码转换

当集合对象同时满足以下两个条件时，对象使用`intset`编码；

- 集合对象保存的所有元素都是整数值；
- 集合对象保存的元素数量不超过512个；

不满足这两个条件则要使用`hashtable`编码。

### 有序集合对象

![1572407304574](F:\typoraImg\1572407304574.png)

执行代码

![1572408103366](F:\typoraImg\1572408103366.png)



![1572409206525](F:\typoraImg\1572409206525.png)

![1572409320229](F:\typoraImg\1572409320229.png)

![1572409591534](F:\typoraImg\1572409591534.png)

**为什么有序集合要同时使用跳跃表和字典来实现**

![1572409654843](F:\typoraImg\1572409654843.png)

#### 编码转换

当有序集合对象同时满足以下两个条件时，对象使用`ziplist`编码；

- 有序集合保存的元素数量小于128个；
- 有序集合保存的所有元素成员的长度都小于64字节；

不满足上面两个条件的有序集合对象将使用`skiplist`编码；

### 类型检查与命令多态

![1572487992863](F:\typoraImg\1572487992863.png)

#### 类型检查的实现

​		在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后在决定是否执行该命令。

​		类型特定命令进行的类型检查时通过`redisObject`结构的`type`属性来实现的。

#### 多态命令的实现

![1572488216213](F:\typoraImg\1572488216213.png)

### 内存回收

​		Redis在对象系统中采用了引用计数的方式来跟踪每个对象的引用信息。从而对一些对象进行内存回收。

![1572496599272](F:\typoraImg\1572496599272.png)

### 对象共享

![1572497062884](F:\typoraImg\1572497062884.png)

可以使用`object refcount`命令来查看某个键的值对象的引用计数。

### 对象的空转时长

![1572498551986](F:\typoraImg\1572498551986.png)

可以使用`object idletime`命令打印给定键的空转时长

### 重点

![1572498734520](F:\typoraImg\1572498734520.png)

# 单机数据库的实现

## 数据库

![1572499269018](F:\typoraImg\1572499269018.png)

![1572499286370](F:\typoraImg\1572499286370.png)

### 切换数据库

![1572499670742](F:\typoraImg\1572499670742.png)

### 设置键的生存时间或过期时间

![1572502743226](F:\typoraImg\1572502743226.png)

![1572502931275](F:\typoraImg\1572502931275.png)

![1572503073008](F:\typoraImg\1572503073008.png)

![1572503103903](F:\typoraImg\1572503103903.png)

### 过期键删除策略

![1572518687978](F:\typoraImg\1572518687978.png)

#### 定时删除

​		定时删除对内存时最友好的，但是对CPU是最不友好的。服务器创建大量的定时器，对CPU的消耗很大。可能对服务器的响应时间和吞吐量造成影响。

​		此外，创建一个定时器要用Redis服务器中的时间事件，而时间事件的用`无序链表`来实现的，查找一个事件的时间复杂度为O（N）。比较低效。

#### 惰性删除

​		惰性删除对CPU是最友好的，对内存是最不友好的，因为过期的键持续保存在内存中，只有等到下一次取出时才会释放。

​		过多的过期键无法被删除，甚至可以看作这是一种内存泄漏。

![1572519069530](F:\typoraImg\1572519069530.png)

#### 定期删除

![1572519161676](F:\typoraImg\1572519161676.png)

### 重点

![1572520345966](F:\typoraImg\1572520345966.png)

![1572520358928](F:\typoraImg\1572520358928.png)

## RDB持久化

​		因为Redis是内存数据库，如果没有办法将内存中的数据存到磁盘，那么服务器一旦退出，服务器中的数据库状态也会消失不见。

​		解决这个问题，需要使用Redis的RDB的持久化功能。

![1572572978066](F:\typoraImg\1572572978066.png)

### RBD文件的生成和载入

![1572573069803](F:\typoraImg\1572573069803.png)

Redis没有主动载入RDB文件的命令，只要Redis服务器启动时检测到RDB文件存在就会自动载入，RDB载入时，服务器会处于阻塞状态。

![1572573141765](F:\typoraImg\1572573141765.png)

#### 命令执行时的服务器状态

##### 执行save

![1572573386817](F:\typoraImg\1572573386817.png)

##### 执行bgsave

![1572573412119](F:\typoraImg\1572573412119.png)

![1572573479759](F:\typoraImg\1572573479759.png)

### 间隔性保存

![1572573563666](F:\typoraImg\1572573563666.png)

#### dirty计数器和lastsave属性

![1572573707402](F:\typoraImg\1572573707402.png)

### RDB文件结构

​		**RDB文件保存的是二进制数据。**

![1572573919351](F:\typoraImg\1572573919351.png)

![1572574050519](F:\typoraImg\1572574050519.png)

![1572574080410](F:\typoraImg\1572574080410.png)

![1572574163677](F:\typoraImg\1572574163677.png)

#### 字符串对象

![1572575606389](F:\typoraImg\1572575606389.png)

![1572575619783](F:\typoraImg\1572575619783.png)

#### 列表对象

![1572575697343](F:\typoraImg\1572575697343.png)

![1572575713218](F:\typoraImg\1572575713218.png)

#### 集合对象

![1572575730353](F:\typoraImg\1572575730353.png)

![1572575739734](F:\typoraImg\1572575739734.png)

#### 哈希表对象

![1572575767125](F:\typoraImg\1572575767125.png)

![1572575784527](F:\typoraImg\1572575784527.png)

#### 有序集合对象

![1572575809608](F:\typoraImg\1572575809608.png)

![1572575824983](F:\typoraImg\1572575824983.png)

### 重点

![1572576142994](F:\typoraImg\1572576142994.png)

## AOF持久化

​		与RDB持久化通过**保存数据库中的键值对**来记录数据库状态不同，AOF持久化是通过**保存Redis服务器所执行的写命令**来记录数据库状态的。

![1572576312974](F:\typoraImg\1572576312974.png)

### AOF文件的载入与数据还原

![1572581504833](F:\typoraImg\1572581504833.png)

### AOF重写

![1572581578352](F:\typoraImg\1572581578352.png)

#### AOF重写原理

​		通过读取某个键的值来保存一条Redis语句来记录键值对，代替之前记录这个键值对的多个命令，而不是保存多条关于该键的值操作语句。

![1572581809572](F:\typoraImg\1572581809572.png)

#### AOF后台重写

​		AOF重写程序会进行大量的写操作，导致调用这个函数的线程被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以在重写AOF文件期间，Redis将无法处理客户端的其它命令请求。

![1572582028316](F:\typoraImg\1572582028316.png)

### 重点

![1572582181870](F:\typoraImg\1572582181870.png)

## 文件事件

![1572584219398](F:\typoraImg\1572584219398.png)

![1572659440383](F:\typoraImg\1572659440383.png)

## 时间事件

![1572659507793](F:\typoraImg\1572659507793.png)

### 实现

![1572659556702](F:\typoraImg\1572659556702.png)

## 重点

![1572659719431](F:\typoraImg\1572659719431.png)

## 客户端

![1572659866002](F:\typoraImg\1572659866002.png)

​		Redis**服务器状态结构的clients**属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或查找某个客户端。都可以通过遍历clients链表来完成。

### 重点

![1572660697182](F:\typoraImg\1572660697182.png)

![1572660712062](F:\typoraImg\1572660712062.png)

## 服务器

### 命令执行过程

![1572660837782](F:\typoraImg\1572660837782.png)

### serverCron函数

![1572661396021](F:\typoraImg\1572661396021.png)

#### 更新服务器时间缓存![1572661498731](F:\typoraImg\1572661498731.png)

#### 更新LRU时钟

​		也是服务器时间缓存的一种，每个`Redis`对象都会有一个`lru`属性，这个属性保存了**对象最后一次被命令访问的时间**.

#### 更新服务器每秒执行命令的次数

![1572661719175](F:\typoraImg\1572661719175.png)

#### 更新服务器内存峰值记录

![1572661786280](F:\typoraImg\1572661786280.png)

#### 处理sigterm信号![1572661850163](F:\typoraImg\1572661850163.png)

​		当`serverCron`函数执行的时候,会检查服务器状态的`shutdown_asap`属性,并根据属性的值决定是否关闭服务器.

#### 管理客户端资源

![1572661942160](F:\typoraImg\1572661942160.png)

#### 管理数据库资源

​		删除过期键,并在有需要时,对字典进行收缩操作.

#### 执行被延迟的BGREWRITEAOF

![1572662015874](F:\typoraImg\1572662015874.png)

​		当`serverCron`函数执行的时候,会检查`BGSAVE`命令或者`BGREWRITEAOF`命令是否正在执行,如果这两个命令都没在执行,并且`aof_rewrite_scheduled`属性的值为**1**,那么服务器就会执行之前被推延的`BGREWRITEAOF`命令.

#### 查看持久化操作的运行状态

![1572662677562](F:\typoraImg\1572662677562.png)

### 初始化服务器

​		初始化server的工作由`initServerConfig`函数完成.

![1572668980443](F:\typoraImg\1572668980443.png)

![1572668985780](F:\typoraImg\1572668985780.png)

### 重点

![1572669236443](F:\typoraImg\1572669236443.png)

# 多机数据库的实现

## 复制

![1572669337016](F:\typoraImg\1572669337016.png)

![1572669360025](F:\typoraImg\1572669360025.png)

### 旧版复制

![1572669698978](F:\typoraImg\1572669698978.png)

![1572669754550](F:\typoraImg\1572669754550.png)

#### 主从服务器同步过程

![1572758938525](F:\typoraImg\1572758938525.png)

#### 旧版同步的缺陷

![1572759240640](F:\typoraImg\1572759240640.png)

![1572767985491](F:\typoraImg\1572767985491.png)

### 新版复制

​		解决了旧版复制功能在断线后重复制效率低下的问题

![1572768073578](F:\typoraImg\1572768073578.png)

### 复制的实现

- 设置主服务器的地址和端口
- 建立套接字连接
- 发送ping命令
- 身份验证
- 发送从服务器端口信息（监听端口号）
- 同步
- 命令广播

### 重点

![1572768999135](F:\typoraImg\1572768999135.png)

## Sentinel

![1572833650451](F:\typoraImg\1572833650451.png)

![1572833663329](F:\typoraImg\1572833663329.png)

![1572833673711](F:\typoraImg\1572833673711.png)

## 集群

​		Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。

### 节点

![1572833865990](F:\typoraImg\1572833865990.png)

#### 启动节点

![1572834133480](F:\typoraImg\1572834133480.png)

#### 集群数据结构

![1572834524269](F:\typoraImg\1572834524269.png)

![1572834568405](F:\typoraImg\1572834568405.png)

### 槽指派

![1572834654948](F:\typoraImg\1572834654948.png)

![1572834737207](F:\typoraImg\1572834737207.png)

​		如果客户端发送命令对应键的槽不属于当前的服务器（节点），那么服务器会返回MOVED错误给客户端，并携带正确的槽所属服务器的地址和端口，让客户端重新执行命令。

### 重点

![1572922608951](F:\typoraImg\1572922608951.png)

## 发布订阅

![1572921143198](F:\typoraImg\1572921143198.png)

​		还支持相匹配的模式的订阅，执行`subscribe news.[ie]t`

![1572921214917](F:\typoraImg\1572921214917.png)

### 频道的订阅与退订

pubsub_channels字典中记录了被订阅频道和订阅客户端的信息（链表）。

![1572921363177](F:\typoraImg\1572921363177.png)

退订使用命令`UNSUBSCTIBE`

### 模式的订阅与退订

![1572921715855](F:\typoraImg\1572921715855.png)

![1572921740978](F:\typoraImg\1572921740978.png)

- 订阅使用命令`PSUBSCRIBE`

- 退订使用命令`PUNSUBSCRIBE`

### 发送消息

![1572921951290](F:\typoraImg\1572921951290.png)

### 查看订阅信息

- pubsub channels

![1572922067543](F:\typoraImg\1572922067543.png)

- pubsub numsub

  ![1572922212151](F:\typoraImg\1572922212151.png)

  ![1572922232907](F:\typoraImg\1572922232907.png)

- pubsub numpat

  ![1572922538860](F:\typoraImg\1572922538860.png)

### 重点

![1572922579721](F:\typoraImg\1572922579721.png)

## 事务

![1572922913573](F:\typoraImg\1572922913573.png)

### 事务开始

![1572922948755](F:\typoraImg\1572922948755.png)

### 执行事务

![1572925730807](F:\typoraImg\1572925730807.png)

### WATCH命令的实现

![1572925804332](F:\typoraImg\1572925804332.png)

![1572925847048](F:\typoraImg\1572925847048.png)

### 事务的ACID性质

### ![1572926013518](F:\typoraImg\1572926013518.png)

